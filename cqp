#!/usr/bin/env perl
use lib qw(/home/jona/Projects-ijs/CQP/lib ./mylib);
use lib qw( /home/jona/usr/cwb/CQP/lib /home/jona/usr/cwb/CQP/mylib /home/jona/usr/cwb/share/perl5 /home/jona/usr/cwb/lib64/perl5 /home/jona/usr/cwb/lib64/perl5/auto );

# TODO 2011-03-30
# - link iz imena korpusa na info file DONE (differently)
# - tooltipe na link na register corpusov in info o corpusu DONE
# - encoding v info file DONE
# - use encoding

# TODO 2011-03-24
# Evo, tole:
# - Preuredit iskalno maslo da je query na začetku DONE
# - Help pop ups in navodila DONE
# - wordlist da tudi podpira prikaz anotacij
# - wordlist totals na vrhu
# - reduce preimenovati v sample; context preimenovati v kwic; cut
#     preimenovati v all DONE
# - usposobit UTF-8, podpirat tudi 8bit encoding + BUG v wordlistih
# - simple search . gre v ? DONE (just help bug)
# - css bug z ozadjem DONE
# - ignoriranje velikih črk
# - export v tabeli
# - metadata: prikaz info fileta
# - prikaz iz katerega besedila je posamezen hit (structural attributes)

# Sortiranje:
# - po hit string, en token levo, en token desno
# - ascending, descending, od spredaj, a tergo
# - po besedi oz. poljubnem drugem positional attribute
# - 2 ali trije ključi

# Further work:
# - paralelni korpusi
# - kolokacije
# - izbira podkorpusa glede na structural attributes // glej spook

# SPOOK concord: http://nl.ijs.si/et/project/SPOOK/konkor/ 
# Para corpora: http://nl2.ijs.si/index-bi.html
# mimgrede: ALIGNED imenuje korpus, aligned je pa po 'seg'


#glej: corpus.leeds.ac.uk./ serge cqp search
#spredi zadi, beseda lemi
#+ reverse sorts
#parallel corpora
#
# context link: one hit with metainfo, wider context (paragraph mode)
# and all tags
# structural attributes: searchable? -> enega za link na document metadata
# generic id documenta, source id cca ena beseda za izpis
# metapodatki & paragraph mode

# bug: sanitize can't work (readonly)
# sort: zadnja levega, prva desnega etc. --- glej primere iz maila
# TODO:
# corpus browser with permalinks DONE
# add corpus info link from registry ?
# sentences-> to paragraphs
# tags in paragraphs: colors and /
# context: to words OK
# tables: no wrap OK
# reduce: no next/prev OK
# properly limit results: fix prev/next limits OK (more intuitive Next)
# add case insensitive option: default?
# paragraph, wordlist views OK - sentences
# macro cases: frekvenčni leksikon (po query, cel korpus :-) 
#   s search/display options
# logika soritranja
# sort po cqp opcijah -- predlagaj interface
# dokumentacija v mouse-over balonih
# cwb-scan-corpus support?

# TODO:
# fix attribute printing as per http://nl2.ijs.si/fpj.html DONE
# display structural attributes DONE (with caveats - pending)
# query compositing: http://nl2.ijs.si/fpj.html
# promote errors to the renderer somehow PARTIAL, need fixes
# parallel corpora

# Deployment:
# beta + utf test && deploy in parallel on mantra

#WISH LIST:
#rezultati: levo znamka o viru, na besedo klik v kontekst
#po vseh rezultatih, sortiranje po levem, desnem kontekstu, mogoče odzadnje po zadetku (odzadnji slovar princip)
#izpiše samo sample - default opcija, a velika (cut 1000)
#kolokacije
#v bodočnosti tudi vzporedni korpusi, npr. http://nl2.ijs.si/index-bi.html

# Production:
#MOJO_MODE=production ./myapp.pl
#mkdir log/

use Mojolicious::Lite;
#use CWB::Web::Search;
use IO::File;
use IO::Dir;
use CWB::Web::Query;
use CWB::CL;
use Encode 'decode';

plugin 'charset' => {charset => 'utf-8'};
plugin 'tag_helpers_extra';
plugin 'pod_renderer';

app->secret('re9phoothieX4dah4chi');
my $maxsize = 5000;

my $sanitize;  # param sanitization callback
my $tabulator; # multi attribute tabulator callback
my $utfizator; # fix utf8 misencoding from html callback

# config
# possibly use the config helper?
my $config = plugin json_config => {
#       file      => '/etc/cqp.conf',
        stash_key => 'config',
        default   => { registry => '/usr/local/share/cwb/registry:/usr/local/cwb/registry' },
    };
$config->{root} =~ s{^(.*)/$}{$1};
app->log->info("App web root: '$config->{root}'.");

$ENV{CORPUS_REGISTRY} = $CWB::CL::Registry =  $ENV{CORPUS_REGISTRY} ||= $config->{registry};
app->log->info("Registry at $CWB::CL::Registry.");

#get registry
#change this to parse all registries and build a list of corpora
my @reg = split (':', $CWB::CL::Registry);
my @corpora =
  grep {
    -f $_  and not ( m{/[#]} or m {[#~]$});
  } map {
    my $dirname = $_;
    map { "$dirname/$_" } IO::Dir->new($dirname)->read;
  } @reg;
app->log->info("Corpora: " . join (", ", @corpora) );

foreach my $reg (@corpora) {
  $reg =~ m{.*/([^/]+)$};  my $corpus = uc($1);
  app->log->info("Scanning registry file at $reg for $corpus.");
  $config->{corpora}{$corpus} = {
				 name => '',
				 align => '',
				 info => '',
				 attributes => [],
				 structures => [],
				};
  my $fh = new IO::File;
  $fh->open($reg, '<') or die "Could not open $reg for reading.\n";
  while (<$fh>) {
    $config->{corpora}{$corpus}{name} = $1
      if m/NAME\s+"([^#]*)"/ ;
    $config->{corpora}{$corpus}{align} = $1
      if m/ALIGN\s+([^# \n]*)/ ;
    $config->{corpora}{$corpus}{info} = $1
      if m/INFO\s+([^# \n]*)/ ;
    push @{$config->{corpora}{$corpus}{attributes}}, $1
      if m/ATTRIBUTE\s+([^# \n]*)/ ;
      push @{$config->{corpora}{$corpus}{structures}}, $1
	if m/STRUCTURE\s+([^# \n]*)/ ;
  }
  $fh->close;
  $config->{corpora}{$corpus}{name} = ucfirst(lc($corpus)) unless $config->{corpora}{$corpus}{name};
  app->log->info( "Corpus name is: $config->{corpora}{$corpus}{name} with " . scalar @{$config->{corpora}{$corpus}{attributes}} . " attributes:" . (join ', ', @{$config->{corpora}{$corpus}{attributes}}) . '.' );
  app->log->info("Registry file $reg processed as $corpus ($config->{corpora}{$corpus}{name}).");

  if ($config->{corpora}{$corpus}{info}) {
    $fh->open($config->{corpora}{$corpus}{info}, '<:encoding(UTF-8)') or die "Could not open $config->{corpora}{$corpus}{info} for reading.\n";
    my $description;
    while (<$fh>) {
      $description = $1 || 'en'
	and $config->{corpora}{$corpus}{description}{$description} = ''
	  or next if m/^DESCRIPTION\s*([^# \n]*)/;
      $config->{corpora}{$corpus}{description}{$description} .= $_
	if ($description);
      $config->{corpora}{$corpus}{encoding} = $1
	if m/ENCODING\s+([^# \n]*)/ ;
      $config->{corpora}{$corpus}{tooltips}{lc($1)}{$2}{$3 ? $3 : 'en'} = $4
	if m/(ATTRIBUTE|STRUCTURE)\s+([^# \n]+)\s+(?:([^# \n]+)\s+)?"([^#]*)"/ ;
    }
    app->log->info("Info file $config->{corpora}{$corpus}{info} for $corpus processed.");
    $config->{corpora}{$corpus}{encoding} //= 'UTF-8';
    app->log->info("Encoding for $corpus set to $config->{corpora}{$corpus}{encoding}.");
    $fh->close;
  }
}

app->log->info("Ready to serve requests.");

# routes and controllers
under ( $config->{root} );

get "/" => sub { $sanitize->(shift); } =>'index';

get "/style.css" => 'style';

get "/:corpus" => sub {
  my $self = shift;
  $self->stash(corpus => uc($self->param('corpus')) );
} => 'corpus';


get "/:corpus/search" => sub {
  my $self = shift;
# warn $self->helper(dumper=> $self->stash); #calls Data::Dumper
  warn $self->dumper($self->param);

  $self->app->log->info("Query was: " . $self->param('query'));
  my $corpus = uc($self->param('corpus'));

  $self->app->log->info("Redirecting.")
    and $self->redirect_to('index')
      and return
	unless $self->param('query')
	  and $config->{corpora}{$corpus};

  $self->app->log->info("CWB::Web::Query init on $corpus.");
  my $search = new CWB::Web::Query $corpus;
  die "Error accessing corpus.\n" unless ref $search;
  $search->on_error( sub { warn join("\n", @_) . "\n"; } );

  $sanitize->($self); # sanitize parameters, set defaults

  unless ($self->param('display') eq 'wordlist') {

    #only return a sample of results
    if ($self->param('listing') eq 'all') {
      #shifting in the list if using the cut method and more
      $search->cut($self->param('startfrom') + $self->param('size'));
    } else {
      $self->param('listing', 'sample');
      $search->reduce($self->param('size'));
    }

    # window and context size are specified in CQP syntax
    # $search->context("1 s", "1 s");  # for sentence display
    $search->context('' . $self->param('contextsize') . ' words',
		     '' . $self->param('contextsize') . ' words');
    $search->context('1 s', '1 s') if $self->param('display') eq 'sentences';
    $search->attributes(scalar $self->param('show') ?
			$self->param('show') : 'word' );
    $search->structures($self->param('struct'))
      if $config->{corpora}{$corpus}{structures} and $self->param('struct') ;
  } else { #wordlist
    $search->context('0 words', '0 words');
    $search->attributes('wordlist');
    $self->app->log->info("Passed wordlist as attribute parameter.");
  }

  # fix-up query string
  my $query = $self->param('query');
  if ( $query =~ m/"/ ) {
    $self->app->log->info("Passing as a CQP-formatted query.")
  } else  {
    $query =~ s/(?<!\\)[*]/.*/gm; $query =~ s/(?<!\\)[?]/./gm;
    $query = join(' ',
		   map {
		   '['
		     . (defined $self->param('search') ?
			$self->param('search') : 'word')
		       . '="' . $_ . '"]'
		     } split('\s+', $query)
		  );
    $self->app->log->info("Passing query as $query.");
  }

  my @matches;
  eval { @matches = $search->query($query); } ;
  $self->app->log->info("Query errors: $@") if $@;
  $self->app->log->info("Query processed.");

  $self->param('startfrom', 0)
    unless $self->param('startfrom') < scalar @matches;

  my @structs = $self->param('structs');

  $self->render( template=>'search',
		 size=>$self->param('size'), #stash them!
		 startfrom=>$self->param('startfrom'),
		 listing=>$self->param('listing'),
		 contextsize=>$self->param('contextsize'),
		 query=>$self->param('query'),
		 qquery=>$query,
		 corpus=>uc($corpus),
		 search=>$search,
		 matches=>\@matches,
		 tc=>$tabulator,
		 utf=>$utfizator,
		 structures=>\@structs,
	       );
} => 'search';

# use this to redirect
$sanitize = sub {
  my $self = shift;

  $self->param('contextsize', 10)
    unless $self->param('contextsize')
      and '' . $self->param('contextsize') =~ m{[0-9]+};
  $self->param('size', 50)
    unless $self->param('size')
      and '' . $self->param('size') =~ m{[0-9]+}
      and $self->param('size') <= $maxsize;
  $self->param('startfrom', 0)
    unless $self->param('startfrom')
      and '' . $self->param('startfrom') =~ m{[0-9]+}
      and $self->param('startfrom') <= $maxsize;

};

$tabulator = sub {
  my $string = shift;
  return $string unless $string =~ m{/};
  my $o = '<span class="part">'; my $c = '</span>';
  my @tokens = split(/\s+/, $string);
  @tokens = map {
    my @parts = split('/', $_);
    '<span class="token">' . $o . join("$c$o", @parts) . $c . '</span>';
  } @tokens;
  return join(' ', @tokens);
};

$utfizator = sub {
  my $string = Encode::decode('utf8', new Mojo::ByteStream(shift)->html_unescape);
  $string =~ s/.&frac34;/&#x017E;/g;
  $string =~ s/.&frac12;/&#x017D;/g;
  $string =~ s/D.&frac14;/&#272;/g;
  return $string;
} ;

app->start;


__DATA__

@@ index.html.ep
% layout 'main', title=>'Form';

% if ($config->{blurb}) {
  <p><%== $config->{blurb} %></p>
% }

<div class="corpora">
 <p>Available corpora:</p>
 <ul>
% foreach my $corpus ( sort keys %{$config->{corpora}} ) {
   <li><a href="<%= $config->{root} . '/' . lc($corpus) %>"><b><%= $corpus %></b>: <%= $config->{corpora}{$corpus}{name} %></a></li>
% }
 </ul>


@@ corpus.html.ep
% layout 'main', title=>'Form';
%= include 'form', query=>undef, contextsize=>10, size=>50, startfrom=>0, listing=>'all'

%#Looking for config for <%== $corpus %> in <%= $config->{corpora}{uc($corpus)}{encoding} %>
%#= dumper $config->{corpora}{uc($corpus)};
% if ($config->{corpora}{uc($corpus)}{description}{en}) {
  <div class="description">
    <%== $config->{corpora}{uc($corpus)}{description}{en} %>
  </div>
% }


@@ form.html.ep
  <div class="form">
  <%= form_for "/$config->{root}/" . lc($corpus) . "/search", ( method => "get") => begin %>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Query</em>The search query can contain simple words with optional ? and * place-holders. Your query will be converted into a CQP langauge query, using the 'Search' attributes bellow. The search result page will display how the simple search is transformed into a CQP query. If CQP syntax (triggered by any use of quoting in the search query) is detected, no conversion is applied and the 'Search' attributes are ignored. </span>
  Query</a>: <%= text_field 'query', size=>60 %>
    <br>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Search attributes</em>Select the attribute the search is to be performed on. If you need different attributes in the same query, you need to use the CQP syntax. When using CQP syntax, the selected Search attribute is ignored. The attributes are extracted from the corpus description in the corpus registry (so possibly some are less useful then others).</span>
    Search</a>:
% my $checked = 0;
% foreach my $att (@{$config->{corpora}{$corpus}{attributes}}) {
  % if ($config->{corpora}{$corpus}{tooltips}{attribute}{$att}{en}) {
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em><%= $att %></em><%= $config->{corpora}{$corpus}{tooltips}{attribute}{$att}{en} %></span>
  % }
     <%= radio_button_x 'search' => $att, $checked++ ? () : (checked => 'checked') => begin %><%= $att %><% end %>
  % if ($config->{corpora}{$corpus}{tooltips}{attribute}{$att}{en}) {
   </a>
  % }
% }
    <br>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Show attributes</em>Select which attributes are to be displayed with your search results. If multiple attributes are selected, they will be aligned horizontally and displayed in different colors. The attributes are extracted from the corpus description in the corpus registry (so possibly some are less useful then others).</span>
    Show</a>:
% $checked = 0;
% foreach my $att (@{$config->{corpora}{$corpus}{attributes}}) {
  % if ($config->{corpora}{$corpus}{tooltips}{attribute}{$att}{en}) {
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em><%= $att %></em><%= $config->{corpora}{$corpus}{tooltips}{attribute}{$att}{en} %></span>
  % }
     <%= check_box_x 'show' => $att, $checked++ ? () : (checked => 'checked') => begin %><%= $att %><% end %>
  % if ($config->{corpora}{$corpus}{tooltips}{attribute}{$att}{en}) {
   </a>
  % }
% }
    <br>
%# if (@{$config->{corpora}{$corpus}{structures}}) {
%#    <br>
%#    Structures:
%#%   foreach my $att (@{$config->{corpora}{$corpus}{structures}}) {
%#%   next unless $att =~ m/_/;
%#       <%= check_box_x 'struct' => $att => begin %><%= $att %><% end %>
%#%   }
%# }
%#    <br>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Context tokens</em>Set the number or left and right tokens to be displayed in KWIC (keyword in contex) display mode. Note that punctuation characters are also tokens.</span>
    Context tokens</a>: <%= text_field 'contextsize', size=>2, value=>10 %>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Display mode</em>Selects the display mode used to display the results. <b>KWIC</b> (keyword in context) displays the results as a table, with the hit in the middle and the selected number of tokens on both sides. <b>Sentences</b> mode displays the whole sentence, as marked in the corpus, for each hit. <b>Wordlist</b> tabulates the hits and shows the number of occurencies for each hit - to be used with wildcards ('?' and '*') i.e. to find different word forms occurances.</span>
    Display mode</a>: <%= select_field 'display', [qw/kwic sentences wordlist/] %>
    <br>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Listing mode</em><b>Sample</b> displays a random sample of hits. Hit reload to see a different sample. <b>All</b> lists all the hits with result pages.</span>
    Listing mode</a>: <%= select_field 'listing', [qw/sample all/] %>
    <a class="tooltip" href="#"><span class="custom help"><img src="/icons/Help.png" alt="Help" height="48" width="48" /><em>Results</em>Sets the number or results in the random sample or per page when all the results are being listed.</span>
    Results</a>: <%= select_field 'size', [50, 100, 200, 500, 1000, 5000] %>
    <%= hidden_field 'startfrom', value => 0 %>
    <span class="submit"><%= submit_button 'CQP search' %></span>
  <% end %>
  </div>

@@ search.html.ep
% layout 'main', title=>"in $corpus for $query" ;
<%= include 'form' %>
% my $nr_matches = @{$matches};
  <div class="report">
% unless ( $query eq $qquery ) {
   <br>Executed as <span class="querytext"><%= $qquery %></span>.</p>
% }
% if ($nr_matches < $size) {
   <p><b><%= $nr_matches %></b> matches found for <span class="querytext"><%= $query %></span>.
% } else {
   <p><b>Matches <%= $startfrom + 1 %></b> to <b><%= $nr_matches %></b> displayed for <span class="querytext"><%= $query %></span>.
% }
  </div>
%  if ($nr_matches >= $size and $self->param('listing') eq 'all' and $self->param('display') ne 'wordlist') {
  <div class="nav">
  <%= link_to_here { startfrom => $self->param('startfrom') - $self->param('size') >= 1 ? $self->param('startfrom') - $self->param('size') : 0 } => (class=>'prev') => begin %>Prev<% end %>
  <%= link_to_here { startfrom => $self->param('startfrom') + $self->param('size')} => (class=>'next') => begin %>Next<% end %>
 </div>
% }
% if ($nr_matches) {
  <div class="matches">
% if ($self->param('display') eq 'kwic') {
  <table>
%  for (my $i = $startfrom; $i < $nr_matches; $i++) {
%   my $nr = $i + 1;         # match number
%   my $m = $matches->[$i];  # returns result struct without 'context'
    <tr>
     <td class="head"><span class="no">[<%= $nr %>]</sep> <span class="sd"><%= $m->{'cpos'} %></span><span class="structs">
%   foreach my $struct (keys %{$m->{data}}) {
    <span class="struct"><%= $m->{data}{$struct} %></span>
%   }
%   warn "$m->{'kwic'}->{'left'}\n";
     </span></td>
     <td class="left"><%== $tc->($utf->($m->{'kwic'}->{'left'})); %></td>
     <td class="match"><span class="match"><%== $tc->($utf->($m->{'kwic'}->{'match'})); %></span></td>
     <td class="right"><%== $tc->($utf->($m->{'kwic'}->{'right'})); %></td>
    </tr>
%  }
  </table>
% } elsif ($self->param('display') eq 'sentences') {
%  for (my $i = $startfrom; $i < $nr_matches; $i++) {
%   my $nr = $i + 1;         # match number
%   my $m = $matches->[$i];  # returns result struct without 'context'
    <p>
     <span class="no">[<%= $nr %>]</span> <span class="sd"><%= $m->{'cpos'} %></span><span class="structs">
%   foreach my $struct (keys %{$m->{data}}) {
    <span class="struct"><%= $m->{data}{$struct} %></span>
%   }
%   warn "$m->{'kwic'}->{'left'}\n";
     </span>
     <%== $tc->($utf->($m->{'kwic'}->{'left'})); %>
     <span class="match"><%== $tc->($utf->($m->{'kwic'}->{'match'})); %></span>
     <%== $tc->($utf->($m->{'kwic'}->{'right'})); %>
    </p>
%  }
% } elsif ($self->param('display') eq 'wordlist') {
  % my $total = 0; my $wordcount = 0;
  <table>
  %  foreach my $match (@{$matches}) {
    % $wordcount++; $total += $match->[1];
    <tr><td><%= $match->[0] %></td><td class="count"><%= Encode::decode('utf8', $match->[1]) %></td></tr>
%  }
    <tr class="total"><td><%= $wordcount %></td><td class="count"><%= $total %></td></tr>
  </table>
% }
 </div>
%  if ($nr_matches >= $size and $self->param('listing') eq 'all' and $self->param('display') ne 'wordlist') {
  <div class="nav">
  <%= link_to_here { startfrom => $self->param('startfrom') - $self->param('size') >= 1 ? $self->param('startfrom') - $self->param('size') : 0 } => (class=>'prev') => begin %>Prev<% end %>
  <%= link_to_here { startfrom => $self->param('startfrom') + $self->param('size')} => (class=>'next') => begin %>Next<% end %>
 </div>
% }
%}

@@ layouts/main.html.ep
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
 <head>
  <title>CQP Search <%= $title ? " $title" : '' =%></title>
  <link href="<%= '/' . $config->{root} . '/' . 'style.css' %>" rel="stylesheet" type="text/css">
 </head>
 <body>
  <h2><%= link_to 'index' => begin %>
    CQP Search
  <% end %>
 <%= param('corpus') ? ' on ' . $config->{corpora}{uc(param('corpus'))}{name} : '' %></h2>
<%== content %> </body>
</html>

@@ style.css.ep
body { font-family: Palatino, Times, serif;
       font-size: 120%; 
       background-color: #F0F0F0;
}
span.querytext { font-family: monospace; font-size: 110%; font-weight: bold; }
div.nav   { font-weight: bold; font-size: 60%; }
div.nav > a.prev   { float: left; }
div.nav > a.next   { float: right; }
div.nav > a { padding: .5em; padding-left: 1.5em; padding-right: 1.5em;
              background-color: #3E3E3E; color: white;
}
div.matches   { clear: both; }
div.matches { background-color: white;
	      width: 98%;
              padding: 0px;
	      margin-left: auto; margin-right: auto;
}
div.matches table { padding: .5em; background-color: white; }
span.hit  { color: red; font-weight: bold; }
span.match  { color: red; font-weight: bold; }
span.no   { font-weight: bold; }
span.sd   { font-family: sans-serif; font-size: 60%; }
span.structs { display: inline-block }
span.struct   { display: block; font-family: sans-serif; font-size: 50%; }
td  { white-space: nowrap;}
td.head  { white-space: nowrap;}
td.left  { text-align: right; vertical-align: text-bottom;}
td.right { text-align: left;  vertical-align: text-top;}
td.match { text-align: center; padding-left: .5em; padding-right: .5em;
           color: red; font-weight: bold; vertical-align: middle;}
td.count  { text-align: right; padding-left: 1em;}
tr.total  { font-weight: bold;}
tr:nth-child(2n+1) { background-color: #F2F2F2; }
span.token { display: inline-block }
span.part { display: block; text-align: center; }
span.token span.part:nth-child(4n+1) { color: navy; }
span.token span.part:nth-child(4n+2) { color: green; }
span.token span.part:nth-child(4n+3) { color: maroon; }
span.token span.part:nth-child(4n+4) { color: purple; }
span.hlp span.hlptxt { display: none; }
span.hlp:hover span.helptxt { display: block; }
h2 { margin-left: 2em; margin-right: 2em; text-align: center ; }
h2 + p, div.report, div.corpora { margin-left: 4em; margin-right: 4em; }
div.form { margin-left: auto; margin-right: auto; width: 36em;
	   background-color: white;
	   padding: .4em; padding-bottom: .6em; padding-left: .6em;
	   border-left: solid 2px black;
	   border-top: solid 2px black;
	   border-bottom: solid 2px gray;
	   border-right: solid 2px gray;
}
span.submit { float: right; }
div.corpora > li {
  margin-bottom: .2ex;
  margin-top: .2ex;
}
div.description {
  margin: 3ex;
  font-size: 0.8em;
}

/* # tooltips from Alexander Dawson,
   # http://sixrevisions.com/css/css-only-tooltips/ */
a.tooltip {
    border-bottom: 1px dotted #000000; color: #000000; outline: none;
    cursor: help; text-decoration: none;
    position: relative;
}
a.tooltip span {
    display: none;
    position: absolute;
}
a.tooltip:hover span {
    display: block;
    border-radius: 5px 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px;
    box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1); -webkit-box-shadow: 5px 5px rgba(0, 0, 0, 0.1); -moz-box-shadow: 5px 5px rgba(0, 0, 0, 0.1);
    font-family: Calibri, Tahoma, Geneva, sans-serif; font-size: 0.7em;
    position: absolute; left: 1em; top: 2em; z-index: 99;
    margin-left: 0; width: 24em;
}
a.tooltip:hover img {
    border: 0; margin: -10px 0 0 -55px;
    float: left; position: absolute;
}
a.tooltip:hover em {
    font-family: Candara, Tahoma, Geneva, sans-serif; font-size: 1.2em; font-weight: bold;
    display: block; padding: 0.2em 0 0.6em 0;
}
.classic  { padding: 0.8em 1em; }
.custom   { padding: 0.5em 0.8em 0.8em 2em; }
* html a:hover { background: transparent; }
.classic  {background: #FFFFAA; border: 1px solid #FFAD33;  }
.critical { background: #FFCCAA; border: 1px solid #FF3334; }
.help     { background: #9FDAEE; border: 1px solid #2BB0D7; }
.info     { background: #9FDAEE; border: 1px solid #2BB0D7; }
.warning  { background: #FFFFAA; border: 1px solid #FFAD33; }
