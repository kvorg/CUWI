#!/usr/bin/env perl
use lib qw(/home/jona/Projects-ijs/CQP/lib ./mylib);

#glej: corpus.leeds.ac.uk./ serge cqp search
#spredi zadi, beseda lemi
#+ reverse sorts
#parallel corpora
#
# context link: one hit with metainfo, wider context (paragraph mode)
# and all tags
# structural attributes: searchable? -> enega za link na document metadata
# generic id documenta, source id cca ena beseda za izpis
# metapodatki & paragraph mode

# bug: sanitize can't work (readonly)
# sort: zadnja levega, prva desnega etc. --- glej primere iz maila
# TODO:
# corpus browser with permalinks DONE
# add corpus info link from registry ?
# sentences-> to paragraphs
# tags in paragraphs: colors and /
# context: to words OK
# tables: no wrap OK
# reduce: no next/prev OK
# properly limit results: fix prev/next limits OK (more intuitive Next)
# add case insensitive option: default?
# paragraph, wordlist views OK - sentences
# macro cases: frekvenčni leksikon (po query, cel korpus :-) 
#   s search/display options
# logika soritranja
# sort po cqp opcijah -- predlagaj interface
# dokumentacija v mouse-over balonih
# cwb-scan-corpus support?

# TODO:
# fix attribute printing as per http://nl2.ijs.si/fpj.html DONE
# display structural attributes DONE (with caveats - pending)
# query compositing: http://nl2.ijs.si/fpj.html
# promote errors to the renderer somehow PARTIAL, need fixes
# parallel corpora

# Deployment:
# beta + utf test && deploy in parallel on mantra

#WISH LIST:
#rezultati: levo znamka o viru, na besedo klik v kontekst
#po vseh rezultatih, sortiranje po levem, desnem kontekstu, mogoče odzadnje po zadetku (odzadnji slovar princip)
#izpiše samo sample - default opcija, a velika (cut 1000)
#kolokacije
#v bodočnosti tudi vzporedni korpusi, npr. http://nl2.ijs.si/index-bi.html

# Production:
#MOJO_MODE=production ./myapp.pl
#mkdir log/

use Mojolicious::Lite;
#use CWB::Web::Search;
use IO::File;
use IO::Dir;
use CWB::Web::Query;
use CWB::CL;
use Encode 'decode';

plugin 'charset' => {charset => 'utf-8'};
plugin 'tag_helpers_extra';
plugin 'pod_renderer';

app->secret('re9phoothieX4dah4chi');
my $maxsize = 5000;

my $sanitize;  # param sanitization callback
my $tabulator; # multi attribute tabulator callback
my $utfizator; # fix utf8 misencoding from html callback

# config
my $config = plugin json_config => {
#       file      => '/etc/cqp.conf',
        stash_key => 'config',
        default   => { registry => '/usr/local/share/cwb/registry:/usr/local/cwb/registry' },
    };
$config->{root} =~ s{^(.*)/$}{$1};
app->log->info("App web root: '$config->{root}'.");

$ENV{CORPUS_REGISTRY} = $CWB::CL::Registry =  $ENV{CORPUS_REGISTRY} ||= $config->{registry};
app->log->info("Registry at $CWB::CL::Registry.");

#get registry
#change this to parse all registries and build a list of corpora
my @reg = split (':', $CWB::CL::Registry);
my @corpora =
  grep {
    -f $_  and not ( m{/[#]} or m {[#~]$});
  } map {
    my $dirname = $_;
    map { "$dirname/$_" } IO::Dir->new($dirname)->read;
  } @reg;
app->log->info("Corpora: " . join (", ", @corpora) );

foreach my $reg (@corpora) {
  $reg =~ m{.*/([^/]+)$};  my $corpus = uc($1);
  app->log->info("Scanning registry file at $reg for $corpus.");
  $config->{corpora}{$corpus} = {
				 name => '',
				 attributes => [],
				 structures => [],
				};
  my $fh = new IO::File;
  $fh->open($reg, '<') or die "Could not open $reg for reading.\n";
  while (<$fh>) {
    $config->{corpora}{$corpus}{name} = $1
      if m/NAME\s+"([^#]*)"/ ;
    push @{$config->{corpora}{$corpus}{attributes}}, $1
      if m/ATTRIBUTE\s+([^# \n]*)/ ;
      push @{$config->{corpora}{$corpus}{structures}}, $1
	if m/STRUCTURE\s+([^# \n]*)/ ;
  }
  $fh->close;
  $config->{corpora}{$corpus}{name} = ucfirst(lc($corpus)) unless $config->{corpora}{$corpus}{name};
  app->log->info( "Corpus name is: $config->{corpora}{$corpus}{name} with " . scalar @{$config->{corpora}{$corpus}{attributes}} . " attributes:" . (join ', ', @{$config->{corpora}{$corpus}{attributes}}) . '.' );
  app->log->info("Registry file $reg processed as $corpus ($config->{corpora}{$corpus}{name}).");
}

app->log->info("Ready to serve requests.");

# routes and controllers
under ( $config->{root} );

get "/" => sub { $sanitize->(shift); } =>'index';

get "/style.css" => 'style';

get "/:corpus" => sub {
  my $self = shift;
  $self->stash(corpus => uc($self->param('corpus')) );
} => 'corpus';


get "/:corpus/search" => sub {
  my $self = shift;
# warn $self->helper(dumper=> $self->stash); #calls Data::Dumper
  warn $self->dumper($self->param);

  $self->app->log->info("Query was: " . $self->param('query'));
  my $corpus = uc($self->param('corpus'));

  $self->app->log->info("Redirecting.")
    and $self->redirect_to('index')
      and return
	unless $self->param('query')
	  and $config->{corpora}{$corpus};

  $self->app->log->info("CWB::Web::Query init on $corpus.");
  my $search = new CWB::Web::Query $corpus;
  die "Error accessing corpus.\n" unless ref $search;
  $search->on_error( sub { warn join("\n", @_) . "\n"; } );

  $sanitize->($self); # sanitize parameters, set defaults

  #only return a sample of results
  if ($self->param('listing') eq 'cut') {
    #shifting in the list if using the cut method and more
    $search->cut($self->param('startfrom') + $self->param('size'));
  } else {
    $self->param('listing', 'reduce');
    $search->reduce($self->param('size'));
  }

  # window and context size are specified in CQP syntax
  # $search->context("1 s", "1 s");  # for sentence display
  $search->context('' . $self->param('contextsize') . ' words',
		   '' . $self->param('contextsize') . ' words');
  $search->context('1 s', '1 s') if $self->param('display') eq 'sentences';
  $search->attributes(scalar $self->param('show') ?
		      $self->param('show') : 'word' );
  $search->structures($self->param('struct'))
    if $config->{corpora}{$corpus}{structures} and $self->param('struct') ;

  # fix-up query string
  my $query = $self->param('query');
  if ( $query =~ m/"/ ) {
    $self->app->log->info("Passing as a CQP-formatted query.")
  } else  {
    $query =~ s/(?<!\\)[*]/.*/gm; $query =~ s/(?<!\\)[?]/./gm;
    $query = join(' ',
		   map {
		   '['
		     . (defined $self->param('search') ?
			$self->param('search') : 'word')
		       . '="' . $_ . '"]'
		     } split('\s+', $query)
		  );
    $self->app->log->info("Passing query as $query.");
  }

  my @matches;
  eval { @matches = $search->query($query); } ;
  $self->app->log->info("Query errors: $@") if $@;
  $self->app->log->info("Query processed.");

  $self->param('startfrom', 0)
    unless $self->param('startfrom') < scalar @matches;

  my @structs = $self->param('structs');

  $self->render( template=>'search',
		 size=>$self->param('size'), #stash them!
		 startfrom=>$self->param('startfrom'),
		 listing=>$self->param('listing'),
		 contextsize=>$self->param('contextsize'),
		 query=>$self->param('query'),
		 qquery=>$query,
		 corpus=>uc($corpus),
		 search=>$search,
		 matches=>\@matches,
		 tc=>$tabulator,
		 utf=>$utfizator,
		 structures=>\@structs,
	       );
} => 'search';

# use this to redirect
$sanitize = sub {
  my $self = shift;

  $self->param('contextsize', 40)
    unless $self->param('contextsize')
      and '' . $self->param('contextsize') =~ m{[0-9]+};
  $self->param('size', 50)
    unless $self->param('size')
      and '' . $self->param('size') =~ m{[0-9]+}
      and $self->param('size') <= $maxsize;
  $self->param('startfrom', 0)
    unless $self->param('startfrom')
      and '' . $self->param('startfrom') =~ m{[0-9]+}
      and $self->param('startfrom') <= $maxsize;

};

$tabulator = sub {
  my $string = shift;
  return $string unless $string =~ m{/};
  my $o = '<span class="part">'; my $c = '</span>';
  my @tokens = split(/\s+/, $string);
  @tokens = map {
    my @parts = split('/', $_);
    '<span class="token">' . $o . join("$c$o", @parts) . $c . '</span>';
  } @tokens;
  return join(' ', @tokens);
};

$utfizator = sub {
  my $string = Encode::decode('utf8', new Mojo::ByteStream(shift)->html_unescape);
  $string =~ s/.&frac34;/&#x017E;/g;
  $string =~ s/.&frac12;/&#x017D;/g;
  return $string;
} ;

app->start;


__DATA__

@@ index.html.ep
% layout 'main', title=>'Form';

<div class="corpora">
 <p>Available corpora:</p>
 <ul>
% foreach my $corpus ( sort keys %{$config->{corpora}} ) {
   <li><a href="<%= $config->{root} . '/' . lc($corpus) %>"><b><%= $corpus %></b>: <%= $config->{corpora}{$corpus}{name} %></a>
%= dumper $config->{corpora}{uc($corpus)};
   </li>
% }
 </ul>


@@ corpus.html.ep
% layout 'main', title=>'Form';
%= include 'form', query=>undef, contextsize=>10, size=>50, startfrom=>0, listing=>'reduce'


@@ form.html.ep
  <div class="form">
  <%= form_for "/$config->{root}/" . lc($corpus) . "/search", ( method => "get") => begin %>
    Show:
% my $checked = 0;
% foreach my $att (@{$config->{corpora}{$corpus}{attributes}}) {
     <%= check_box_x 'show' => $att, $checked++ ? () : (checked => 'checked') => begin %><%= $att %><% end %>
% }
    <br>
    Search:
% $checked = 0;
% foreach my $att (@{$config->{corpora}{$corpus}{attributes}}) {
     <%= radio_button_x 'search' => $att, $checked++ ? () : (checked => 'checked') => begin %><%= $att %><% end %>
% }
%# if (@{$config->{corpora}{$corpus}{structures}}) {
%#    <br>
%#    Structures:
%#%   foreach my $att (@{$config->{corpora}{$corpus}{structures}}) {
%#%   next unless $att =~ m/_/;
%#       <%= check_box_x 'struct' => $att => begin %><%= $att %><% end %>
%#%   }
%# }
    <br>
    <span class="hlp">Search query<span class="hlptxt">Yada yada.</span></span>: <%= text_field 'query', size=>60 %>
    <br>
    Context words: <%= text_field 'contextsize', size=>2, value=>40 %>
    Display mode: <%= select_field 'display', [qw/context sentences wordlist/] %>
    <br>
    Listing mode: <%= select_field 'listing', [qw/reduce cut/] %>
    Results: <%= select_field 'size', [50, 100, 200, 500, 1000, 5000] %>
    <%= hidden_field 'startfrom', value => 0 %>
    <%= submit_button 'CQP search' %>
  <% end %>
  </div>

@@ search.html.ep
% layout 'main', title=>"in $corpus for $query" ;
<%= include 'form' %>
% my $nr_matches = @{$matches};
  <div class="report">
% unless ( $query eq $qquery ) {
   <br>Executed as <span class="querytext"><%= $qquery %></span>.</p>
% }
% if ($nr_matches < $size) {
   <p><b><%= $nr_matches %></b> matches found for <span class="querytext"><%= $query %></span>.
% } else {
   <p><b>Matches <%= $startfrom + 1 %></b> to <b><%= $nr_matches %></b> displayed for <span class="querytext"><%= $query %></span>.
% }
  </div>
%  if ($nr_matches >= $size and $self->param('listing') eq 'cut') {
  <div class="nav">
  <%= link_to_here { startfrom => $self->param('startfrom') - $self->param('size') >= 1 ? $self->param('startfrom') - $self->param('size') : 0 } => (class=>'prev') => begin %>Prev<% end %>
  <%= link_to_here { startfrom => $self->param('startfrom') + $self->param('size')} => (class=>'next') => begin %>Next<% end %>
 </div>
% }
% if ($nr_matches) {
  <div class="matches">
% if ($self->param('display') eq 'context') {
  <table>
%  for (my $i = $startfrom; $i < $nr_matches; $i++) {
%   my $nr = $i + 1;         # match number
%   my $m = $matches->[$i];  # returns result struct without 'context'
    <tr>
     <td class="head"><span class="no">[<%= $nr %>]</sep> <span class="sd"><%= $m->{'cpos'} %></span><span class="structs">
%   foreach my $struct (keys %{$m->{data}}) {
    <span class="struct"><%= $m->{data}{$struct} %></span>
%   }
%   warn "$m->{'kwic'}->{'left'}\n";
     </span></td>
     <td class="left"><%== $tc->($utf->($m->{'kwic'}->{'left'})); %></td>
     <td class="match"><span class="match"><%== $tc->($utf->($m->{'kwic'}->{'match'})); %></span></td>
     <td class="right"><%== $tc->($utf->($m->{'kwic'}->{'right'})); %></td>
    </tr>
%  }
  </table>
% } elsif ($self->param('display') eq 'sentences') {
%  for (my $i = $startfrom; $i < $nr_matches; $i++) {
%   my $nr = $i + 1;         # match number
%   my $m = $matches->[$i];  # returns result struct without 'context'
    <p>
     <span class="no">[<%= $nr %>]</span> <span class="sd"><%= $m->{'cpos'} %></span><span class="structs">
%   foreach my $struct (keys %{$m->{data}}) {
    <span class="struct"><%= $m->{data}{$struct} %></span>
%   }
%   warn "$m->{'kwic'}->{'left'}\n";
     </span>
     <%== $tc->($utf->($m->{'kwic'}->{'left'})); %>
     <span class="match"><%== $tc->($utf->($m->{'kwic'}->{'match'})); %></span>
     <%== $tc->($utf->($m->{'kwic'}->{'right'})); %>
    </p>
%  }
% } elsif ($self->param('display') eq 'sentences') {
<p>Not implemented.</p>
% }
 </div>
%  if ($nr_matches >= $size and $self->param('listing') eq 'cut') {
  <div class="nav">
  <%= link_to_here { startfrom => $self->param('startfrom') - $self->param('size') >= 1 ? $self->param('startfrom') - $self->param('size') : 0 } => (class=>'prev') => begin %>Prev<% end %>
  <%= link_to_here { startfrom => $self->param('startfrom') + $self->param('size')} => (class=>'next') => begin %>Next<% end %>
 </div>
% }
%}

@@ layouts/main.html.ep
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
 <head>
  <title>CQP Search <%= $title ? " $title" : '' =%></title>
  <link href="<%= '/' . $config->{root} . '/' . 'style.css' %>" rel="stylesheet" type="text/css">
 </head>
 <body>
  <h2><%= link_to 'index' => begin %>
    CQP Search
  <% end %>
 <%= param('corpus') ? ' on ' . $config->{corpora}{uc(param('corpus'))}{name} : '' %></h2>
  % if ($config->{blurb}) {
    <p><%== $config->{blurb} %></p>
  % }
<%== content %> </body>
</html>

@@ style.css.ep
body { font-family: Palatino, Times, serif; font-size: 120%;}
span.querytext { font-family: monospace; font-size: 110%; font-weight: bold; }
div.nav   { font-weight: bold; font-size: 60%; }
div.nav > a.prev   { float: left; }
div.nav > a.next   { float: right; }
div.matches   { clear: both; }
span.hit  { color: red; font-weight: bold; }
span.match  { color: red; font-weight: bold; }
span.no   { font-weight: bold; }
span.sd   { font-family: sans-serif; font-size: 60%; }
span.structs { display: inline-block }
span.struct   { display: block; font-family: sans-serif; font-size: 50%; }
td  { white-space: nowrap;}
td.head  { white-space: nowrap;}
td.left  { text-align: right; vertical-align: text-bottom;}
td.right { text-align: left;  vertical-align: text-top;}
td.match { text-align: center; padding-left: .5em; padding-right: .5em;
           color: red; font-weight: bold; vertical-align: middle;}
tr:nth-child(2n+1) { background-color: #F2F2F2; }
span.token { display: inline-block }
span.part { display: block; text-align: center; }
td span.part:nth-child(4n+1) { color: navy; }
td span.part:nth-child(4n+2) { color: green; }
td span.part:nth-child(4n+3) { color: maroon; }
td span.part:nth-child(4n+4) { color: purple; }
span.hlp span.hlptxt { display: none; }
span.hlp:hover span.helptxt { display: block; }
