#!/usr/bin/env perl
use lib qw(/home/jona/Projects-ijs/CQP/lib ./mylib);

# bug: sanitize can't work (readonly)

# TODO:
# context: to words
# tables: no wrap
# reduce: no next/prev
# add case insensitive option
# macro cases: frekvenčni leksikon (po query, cel korpus :-) 
#   s search/display options
# paragraph mode (odstavek ali po besednem kontekstu, če ni odstavkov)
# add invisible slashes to parts ...
# logika soritranja
# sort po cqp opcijah -- predlagaj interface
# dokumentacija v mouse-over balonih
# cwb-scan-corpus support?

# TODO:
# properly limit results: fix prev/next limits
# paragraph, wordlist views
# fix attribute printing as per http://nl2.ijs.si/fpj.html
# display structural attributes
# query compositing: http://nl2.ijs.si/fpj.html
# promote errors to the renderer somehow
# sorted queries
# collocations and macros with views
# parallel corpora

# Deployment:
# beta + utf test && deploy in parallel on mantra

#WISH LIST:
#rezultati: levo znamka o viru, na besedo klik v kontekst
#po vseh rezultatih, sortiranje po levem, desnem kontekstu, mogoče odzadnje po zadetku (odzadnji slovar princip)
#izpiše samo sample - default opcija, a velika (cut 1000)
#kolokacije
#v bodočnosti tudi vzporedni korpusi, npr. http://nl2.ijs.si/index-bi.html

# Production:
#MOJO_MODE=production ./myapp.pl
#mkdir log/

use Mojolicious::Lite;
#use CWB::Web::Search;
use IO::File;
use CWB::Web::Query;
use CWB::CL;
use Encode 'decode';

plugin 'charset' => {charset => 'utf-8'};
plugin 'tag_helpers_extra';

app->secret('re9phoothieX4dah4chi');
my $maxsize = 5000;

my $sanitize;  # param sanitization callback
my $tabulator; # multi attribute tabulator callback
my $utfizator; # fix utf8 misencoding from html callback

# config
my $config = plugin json_config => {
#       file      => '/etc/cqp.conf',
        stash_key => 'config',
        default   => { registry => '/usr/local/share/cwb/registry:/usr/local/cwb/registry' },
    };
$config->{root} =~ s{^(.*)/$}{$1};
app->log->info("App web root: '$config->{root}'.");
app->log->info("Corpus $config->{corpus}.");

$ENV{CORPUS_REGISTRY} = $CWB::CL::Registry =  $ENV{CORPUS_REGISTRY} ||= $config->{registry};
app->log->info("Registry at $CWB::CL::Registry.");

#get registry
my @reg = split (':', $CWB::CL::Registry);
my $file = lc($config->{corpus});
@reg = grep {  s{(.*)/$}{$1}; -e "$_/$file" } @reg;
my $reg = shift @reg;
die "No registry file for $config->{corpus} found in $CWB::CL::Registry.\n"
  unless $reg;
$reg = "$reg/$file";
app->log->info("Registry file at $reg.");

# get registry info
my @attribute; my @structure;
my $fh = new IO::File;
$fh->open($reg, '<') or die "Could not open $reg for reading.\n";
while (<$fh>) {
  m/^(?:NAME\s+     ([^#]*) (?{ my $x = $^N; chomp $x; $config->{corpus_name} = $x; }) )
    |(?:ATTRIBUTE\s+([^# ]*)(?{ my $x = $^N; chomp $x; push @attribute, $x; }) )
    |(?:STRUCTURE\s+([^# ]*)(?{ my $x = $^N; chomp $x; push @structure, $x; }) )
      /x;
}
$fh->close;
$config->{corpus_name} =~ s/^\"(.*)\"/$1/;
$config->{attributes} = \@attribute;
$config->{structures} = \@structure;
app->log->info("Registry file $reg/$file processed.");

app->log->info("Ready to serve requests.");

# routes and controllers
under ( $config->{root} );

get "/" => sub { $sanitize->(shift); } =>'index';

get "/style.css" => 'style';

get "/search" => sub {
  my $self = shift;
# warn $self->helper(dumper=> $self->stash); #calls Data::Dumper
warn $self->helper(dumper=> $self->param);

  $self->app->log->info("Query was: " . $self->param('query'));

  $self->app->log->info("Redirecting.")
    and $self->redirect_to('index')
      and return
	unless $self->param('query');

  $self->app->log->info("CWB::Web::Query init on $config->{corpus}.");
  my $search = new CWB::Web::Query $config->{corpus};
  die "Error accessing corpus.\n" unless ref $search;
  $search->on_error( sub { warn join("\n", @_) . "\n"; } );

  $sanitize->($self); # sanitize parameters, set defaults

  #only return a sample of results
  if ($self->param('listing') eq 'cut') {
    #shifting in the list if using the cut method and more
    $search->cut($self->param('startfrom') + $self->param('size'));
  } else {
    $self->param('listing', 'reduce');
    $search->reduce($self->param('size'));
  }

  # window and context size are specified in CQP syntax
  # $search->context("1 s", "1 s");  # for sentence display
  $search->context('' . $self->param('contextsize'),
		   '' . $self->param('contextsize'));
  $search->attributes(scalar $self->param('show') ?
		      $self->param('show') : 'word' );
  $search->structures($self->param('struct'))
    if $config->{structures} and $self->param('struct') ;

  # fix-up query string
  my $query = $self->param('query');
  if ( $query =~ m/"/ ) {
    $self->app->log->info("Passing as a CQP-formatted query.")
  } else  {
    $query =~ s/(?<!\\)[*]/.*/gm; $query =~ s/(?<!\\)[?]/./gm;
    $query = join(' ',
		   map {
		   '['
		     . (defined $self->param('search') ?
			$self->param('search') : 'word')
		       . '="' . $_ . '"]'
		     } split('\s+', $query)
		  );
    $self->app->log->info("Passing query as $query.");
  }

  my @matches;
  eval { @matches = $search->query($query); } ;
  $self->app->log->info("Query errors: $@") if $@;
  $self->app->log->info("Query processed.");

  $self->param('startfrom', 0)
    unless $self->param('startfrom') < scalar @matches;

  my @structs = $self->param('structs');

  $self->render( template=>'search',
		 size=>$self->param('size'), #stash them!
		 startfrom=>$self->param('startfrom'),
		 listing=>$self->param('listing'),
		 contextsize=>$self->param('contextsize'),
		 query=>$self->param('query'),
		 qquery=>$query,
		 corpus=>$config->{corpus},
		 search=>$search,
		 matches=>\@matches,
		 tc=>$tabulator,
		 utf=>$utfizator,
		 structures=>\@structs,
	       );
} => 'search';

# use this to redirect
$sanitize = sub {
  my $self = shift;

  $self->param('contextsize', 40)
    unless $self->param('contextsize')
      and '' . $self->param('contextsize') =~ m{[0-9]+};
  $self->param('size', 50)
    unless $self->param('size')
      and '' . $self->param('size') =~ m{[0-9]+}
      and $self->param('size') <= $maxsize;
  $self->param('startfrom', 0)
    unless $self->param('startfrom')
      and '' . $self->param('startfrom') =~ m{[0-9]+}
      and $self->param('startfrom') <= $maxsize;

};

$tabulator = sub {
  my $string = shift;
  return $string unless $string =~ m{/};
  my $o = '<sep class="part">'; my $c = '</sep>';
  my @tokens = split(/\s+/, $string);
  @tokens = map {
    my @parts = split('/', $_);
    '<sep class="token">' . $o . join("$c$o", @parts) . $c . '</sep>';
  } @tokens;
  return join(' ', @tokens);
};

$utfizator = sub {
  return Encode::decode('utf8', new Mojo::ByteStream(shift)->html_unescape);
} ;

app->start;


__DATA__

@@ index.html.ep
% layout 'main', title=>'Form';
%= include 'form', query=>undef, contextsize=>40, size=>50, startfrom=>0, listing=>'reduce'

@@ form.html.ep
  <%= form_for 'search', ( method => "get") => begin %>
    Show:
% my $checked = 0;
% foreach my $att (@{$config->{attributes}}) {
     <%= check_box_x 'show' => $att, $checked++ ? () : (checked => 'checked') => begin %><%= $att %><% end %>
% }
    <br>
    Search:
% $checked = 0;
% foreach my $att (@{$config->{attributes}}) {
     <%= radio_button_x 'search' => $att, $checked++ ? () : (checked => 'checked') => begin %><%= $att %><% end %>
% }
% if (@{$config->{structures}}) {
    <br>
    Structures:
%   foreach my $att (@{$config->{structures}}) {
%   next unless $att =~ m/_/;
       <%= check_box_x 'struct' => $att => begin %><%= $att %><% end %>
%   }
% }
    <br>
    Query: <%= text_field 'query', size=>60 %>
    <br>
    Context: <%= text_field 'contextsize', size=>2, value=>40 %>
    Display: <%= select_field 'listing', [qw/reduce cut/] %>
    Results: <%= select_field 'size', [50, 100, 200, 500, 1000, 5000] %>
    <%= hidden_field 'startfrom', value => 0 %>
    <%= submit_button 'CQP search' %>
  <% end %>

@@ search.html.ep
% layout 'main', title=>"in $corpus for $query" ;
<%= include 'form' %>
% my $nr_matches = @{$matches};
  <div class="report">
% unless ( $query eq $qquery ) {
   <br>Executed as <sep class="querytext"><%= $qquery %></sep>.</p>
% }
% if ($nr_matches < $size) {
   <p><b><%= $nr_matches %></b> matches found for <sep class="querytext"><%= $query %></sep>.
% } else {
   <p><b>Matches <%= $startfrom + 1 %></b> to <b><%= $nr_matches %></b> displayed for <sep class="querytext"><%= $query %></sep>.
% }
  </div>
%  if ($nr_matches >= $size) {
  <div class="nav">
  <%= link_to_here { startfrom => $self->param('startfrom') - $self->param('size')} => (class=>'prev') => begin %>Prev<% end %>
  <%= link_to_here { startfrom => $self->param('startfrom') + $self->param('size')} => (class=>'next') => begin %>Next<% end %>
 </div>
% }
% if ($nr_matches) {
  <div class="matches">
  <table>
%  for (my $i = $startfrom; $i < $nr_matches; $i++) {
%   my $nr = $i + 1;         # match number
%   my $m = $matches->[$i];  # returns result struct without 'context'
    <tr>
     <td><sep class="no">[<%= $nr %>]</sep> <sep class="sd"><%= $m->{'cpos'} %></sep><sep class="structs">
%   foreach my $struct (keys %{$m->{data}}) {
    <sep class="struct"><%= $m->{data}{$struct} %></sep>
%   }
%   warn "$m->{'kwic'}->{'left'}\n";
     </sep></td>
     <td class="left"><%== $tc->($utf->($m->{'kwic'}->{'left'})); %></td>
     <td class="match"><sep class="match"><%== $tc->($utf->($m->{'kwic'}->{'match'})); %></sep></td>
     <td class="right"><%== $tc->($utf->($m->{'kwic'}->{'right'})); %></td>
    </tr>
% }
  </table>
 </div>
%  if ($nr_matches >= $size) {
  <div class="nav">
  <%= link_to_here { startfrom => $self->param('startfrom') - $self->param('size')} => (class=>'prev') => begin %>Prev<% end %>
  <%= link_to_here { startfrom => $self->param('startfrom') + $self->param('size')} => (class=>'next') => begin %>Next<% end %>
 </div>
% }
%}

@@ layouts/main.html.ep
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
 <head>
  <title>CQP Search <%= $title ? " $title" : '' =%></title>
  <link href="style.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <%= link_to 'index' => begin %>
  <h2>CQP Search on <%= $config->{corpus_name} %></h2>
  <% end %>
<%== content %> </body>
</html>

@@ style.css.ep
body { font-family: Palatino, Times, serif; font-size: 120%;}
sep.querytext { font-family: monospace; font-size: 110%; font-weight: bold; }
div.nav   { font-weight: bold; font-size: 60%; }
div.nav > a.prev   { float: left; }
div.nav > a.next   { float: right; }
div.matches   { clear: both; }
sep.hit  { color: red; font-weight: bold; }
sep.no   { font-weight: bold; }
sep.sd   { font-family: sans-serif; font-size: 60%; }
sep.structs { display: inline-block }
sep.struct   { display: block; font-family: sans-serif; font-size: 50%; }
td.left  { text-align: right; vertical-align: text-bottom;}
td.right { text-align: left;  vertical-align: text-top;}
td.match { text-align: center; padding-left: .5em; padding-right: .5em;
           color: red; font-weight: bold; vertical-align: middle;}
sep.token { display: inline-block }
sep.part { display: block; text-align: center; }
sep.part:nth-child(4n+1) { color: navy; }
sep.part:nth-child(4n+2) { color: green; }
sep.part:nth-child(4n+3) { color: maroon; }
sep.part:nth-child(4n+4) { color: purple; }
