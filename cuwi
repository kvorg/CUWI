#!/usr/bin/env perl
use lib qw(/home/jona/Projects-ijs/CQP/lib ./lib /home/jona/Projects-ijs/CQP/lib-extra ./lib-extra);
use lib qw( /home/jona/usr/cwb/CQP/lib /home/jona/usr/cwb/CQP/mylib /home/jona/usr/cwb/share/perl5 /home/jona/usr/cwb/lib64/perl5 /home/jona/usr/cwb/lib64/perl5/auto );

our $VERSION = '0.9';
use Mojolicious::Lite;

use CWB::Model;

use Mojo::Loader;
use Mojo::ByteStream 'b';
use IO::File;
use IO::Dir;
use File::Spec;
use File::Temp;
use Encode 'decode';

plugin 'charset' => {charset => 'UTF-8'};
plugin 'tag_helpers_extra';
#plugin 'pod_renderer'; #park it under root and use for help?

app->secret('re9phoothieX4dah4chi');
app->types->type(perl => 'application/perl');
app->types->type(csv => 'application/csv');
app->types->type(xls => 'application/excel');
my $maxsize = 50000;
my $maxpagesize = 500;

my $sanitize;   # param sanitization callback
my $tabulator;  # multi attribute tabulator callback
my $columnator; # multi attribute tabulator callback for table columns export
my $urlator;    # conditional anchor generator
my $table_export;
my $tooltip;    # tooltip generator

my $loader = Mojo::Loader->new;
my $e = $loader->load('Spreadsheet::Write');
if (ref $e) {
  app->log->info("Module Spreadsheet::Write not available: $e. " .
		 "Install Spreadsheet::Write if you need cvs and excel table result exports.")
} else {
  app->log->info("Module Spreadsheet::Write loader said: $e.") if $e;
  app->log->info("Module Spreadsheet::Write loaded ok.") unless $e;
  $table_export = 1;
}

# config
# possibly use the config helper?
my $config = plugin JSONConfig => {
        stash_key => 'config',
        default   => { registry => '/usr/local/share/cwb/registry:/usr/local/cwb/registry' },
    };
#stuff me in a helper?
app->log->info("Config parsed.");
$config->{tmp} = (
		  ( defined $config->{tmp}
		    and -d $config->{tmp} and -w defined $config->{tmp} ) ?
		  $config->{tmp} :
		  ( $ENV{MOJO_TMPDIR} || File::Spec->tmpdir )
		 );
app->log->info("Temporary directory: $config->{tmp}");
my $model = CWB::Model->new(
			    ( $config->{registry} ? 
			     (registry => $config->{registry}) : () )
			   )
  or die "Could not instantiate CWB::Model, aborting\n";
app->log->info("Instantiated model with registry at '" . $model->registry . "'.");
$model->install_exception_handler(sub { app->log->error(@_); return @_;} );
app->defaults(model => $model);

# peers from config groups
if ($config->{corpora}{GROUPS} #BUG: optimize traversal
    and ref $config->{corpora}{GROUPS} eq 'HASH') {
  app->log->info('Adding groups from config file to CWB Model.');
  foreach my $group (keys %{$config->{corpora}{GROUPS}}) {
    my @members = @{$config->{corpora}{GROUPS}{$group}};
    foreach my $m (@members) {
      app->log->error("Configuration file error: Group $group includes corpus $m, but no such corpus is present in the registry.")
	and next unless exists $model->corpora->{$m};
      push (@{$model->corpora->{$m}->peers}, grep { $_ ne $m } @members);
    }
  }
}

# virtauls from config
if ($config->{corpora}{VIRTUALS} #BUG: optimize traversal
    and ref $config->{corpora}{VIRTUALS} eq 'HASH') {
  app->log->info('Adding virtual corpora from config file to CWB Model.');
  foreach my $virtual (keys %{$config->{corpora}{VIRTUALS}}) {
    my $corpus = $model->virtual($virtual,
		    ((ref ($config->{corpora}{VIRTUALS}{$virtual}{subcorpora}) eq 'ARRAY') ?
		    $config->{corpora}{VIRTUALS}{$virtual}{subcorpora} :
		    []),
		    ((ref ($config->{corpora}{VIRTUALS}{$virtual}{options}) eq 'HASH') ?
		    %{$config->{corpora}{VIRTUALS}{$virtual}{options}} :
		    ())
		   );
    $corpus->description($config->{corpora}{VIRTUALS}{$virtual}{description})
      if $config->{corpora}{VIRTUALS}{$virtual}{description};
    $corpus->peers($config->{corpora}{VIRTUALS}{$virtual}{peers})
      if $config->{corpora}{VIRTUALS}{$virtual}{peers};
    $corpus->tooltips($config->{corpora}{VIRTUALS}{$virtual}{tooltips})
      if $config->{corpora}{VIRTUALS}{$virtual}{tooltips};
  }
}

app->log->info('CWB Model instantiated with corpora: ' .
	       join(', ', $model->list) . '.');

# frequency data - this could be moved to Model
if ( exists $config->{corpora}{OPTIONS}{frequencies}
     and exists $config->{var}
     and -d $config->{var} and -w $config->{var} ) {
  app->log->info('Checking frequencies in '. $config->{var} . ' ...');
  sub MTIME { 9 }; sub SIZE { 7 };
  foreach my $corpus (values %{$model->corpora}) {
    next unless $corpus->can('datahome');
    $config->{var} .= '/' unless substr($config->{var}, -1) eq '/';
    next if ref $config->{corpora}{OPTIONS}{frequencies} eq 'ARRAY'
      and not grep { $_ eq $corpus->name }
	@{$config->{corpora}{OPTIONS}{frequencies}};
    my $var = $config->{var} . $corpus->name . '.';
    foreach my $att (@{$corpus->attributes}) {
      my $file = $var . $att . '.freq';
#      app->log->debug("$file vs " .  $corpus->datahome . "/$att.lexicon");
      unless (-e $file and -r $file and (stat($file))[SIZE] > 0 and (stat($file))[MTIME] > (stat($corpus->datahome . "/$att.lexicon"))[MTIME]) {
	if (exists $config->{corpora}{OPTIONS}{maxfreq}
	    and (stat($corpus->datahome . "/$att.lexicon"))[SIZE] > $config->{corpora}{OPTIONS}{maxfreq} ) {
	  app->log->info("Skipping frequencies for $att in " . $corpus->name . ", file bigger that config option maxfreq.");
	} else {
	  app->log->info("Re-generating frequencies for $att in " . $corpus->name . " to $file.");
	  if (! system ( 'cwb-lexdecode -P ' . $att . ' -f -r ' . $model->registry . ' ' . $corpus->NAME . ' | sort -rn > ' . $file) ) {
	    app->log->error("Re-generating frequiencies for $att in " . $corpus->name . " failed: $?");
	  } else {
	    ${$corpus->stats}{freqs}{$att} = $file;
	  }
	}
      } else {
	#file exists
	${$corpus->stats}{freqs}{$att} = $file;
      }
    }
  }
  app->log->info('Frequency check done.');
} elsif ( exists $config->{corpora}{OPTIONS}{frequencies} ) {
  if ( not exists $config->{var}) {
    app->log->error("Can not generate frequencies: a var directory needs to be specified in config." );
  } else {
    app->log->error("Can not generate frequencies: no writable directory at $config->{var}." )
  }
} else {
  app->log->info('No frequencies requested, none generated.' )
}

my $auth = sub {
  my $self = shift;
  my $authcorpus = $self->param('corpus');
  $self->app->log->info("Authenticating for " . ($authcorpus || 'undef') . ".");

  if ($authcorpus and exists $config->{corpora}{AUTH}{$authcorpus} and $config->{corpora}{AUTH}{$authcorpus}{domain} ) {
    unless ($self->session('username')) {
      $self->app->log->info("Auth triggered for $authcorpus.");
      $self->flash(error => "Corpus $authcorpus requires authentication.") and
	$self->session(redirection => $self->req->url) and
	$self->redirect_to($config->{root} . '/login/' . $authcorpus);
      return 0;
    }
  } else {
    return 1;
  }
};

$config->{root} =~ s{^(.*)/$}{$1};
$config->{root} = 'cuwi' unless $config->{root};
app->log->info("App web root: '$config->{root}'.");

app->log->info("Ready to serve requests.");

# routes and controllers

under ($config->{root});

get "/" => sub { $sanitize->(shift); } =>'index';

get "/logout" => sub {
  my $self = shift;
  $self->session(username=>0);
  $self->redirect_to('/' . $config->{root} );
};

get "/style.css" => sub { shift->render_static('cuwi.css'); };

get "/icons/Help.png" => sub { shift->render_static('icons/Help.png'); };

get "/lib/*libfile" => sub { my $c = shift; $c->render_static('lib/' . $c->param('libfile')); };


get "/:corpus/frequencies/:att" => sub {
  my $self = shift;
  return 0 unless $auth->($self);
  my $corpus = ${$self->stash('model')->corpora}{$self->param('corpus')};
  if ( exists ${$corpus->stats}{freqs}{$self->param('att')} ) {
    $self->res->headers->content_type('text/plain; charset=' . $corpus->encoding);
    my $ss = Mojolicious::Static->new(root=>$config->{var});
    $self->app->log->info("Serving file " . $ss->root .
			  $corpus->name . '.' . $self->param('att') . '.freq');
    $ss->serve($self, $corpus->name . '.' . $self->param('att') . '.freq');
    $self->rendered;
  } else {
    $self->redirect_to('index');
  }
};

get "/:corpus" => sub {
  my $self = shift;
  return 0 unless $auth->($self);

  $model->install_exception_handler(sub { $self->stash(cwbexception => [@_]);
					  app->log->error(@_); } );
  my $corpus = ${$self->stash('model')->corpora}{$self->param('corpus')};

  $self->app->log->info("Redirecting to registry, corpus init aborted.")
    and $self->redirect_to('index')
      and return
	unless $self->param('corpus')
	  and $corpus and $corpus->isa('CWB::Model::Corpus');

  $self->stash(corpus => $corpus, tooltip => $tooltip );
} => 'corpus';

get "/:corpus/search" => sub {
  my $self = shift;
  return 0 unless $auth->($self);

  # BUG: should not allow cpos on virtual corpora

  # redirect to peer?
  if ( $self->param('peer')
       and $self->param('peer') ne $self->param('corpus') ) {
    my $query = $self->req->url->query;
    my $url = '/' . $config->{root} . '/' . $self->param('peer') . '/search?';
    $self->app->log->info('Redirecting query to peer ' . $self->param('peer') . '.');

    $self->redirect_to($url . $query);
  }

  # BUG: here?
  $model->install_exception_handler(sub { $self->stash(cwbexception => [@_]);
					  app->log->error(@_); } );

  if ($self->param('cpos')) {
    $self->app->log->info('Received cpos query: ' . $self->param('cpos') . ' from ' . $self->tx->remote_address . '.');
  } else {
    $self->app->log->info('Received query: ' . $self->param('query')  . ' from ' . $self->tx->remote_address . '.');
  }
  $self->app->log->info('CWB::Model::Corpus init on "' . $self->param('corpus') . '".');
  my $corpus = ${$self->stash->{model}->corpora}{$self->param('corpus')};

  $self->app->log->info("Redirecting to registry, corpus init aborted.")
    and $self->redirect_to('index')
      and return
	unless $self->param('query')
	  and $corpus and $corpus->isa('CWB::Model::Corpus');

  # sanitize parameters, set defaults (perhaps redirect)
  $sanitize->($self); # revert to old logic, ParamValidate in progress
  # NASTY - we now have controller params and these, and some parts
  #         use ones or the others - cleanup
  my %params;
  my %c_attributes = map { $_ => 1 } @{$corpus->attributes};
  my %c_structures = map { $_ => 1 } @{$corpus->structures};
  my %c_aligns     = map { $_ => 1 } @{$corpus->alignements};

  $params{cpos} = $self->param('cpos') 
    if $self->param('cpos') and $self->param('cpos') =~ m/^\d+$/;
  $params{query} = $self->param('query');
  $params{class} = $self->param('class')
    if not $corpus->can('file')
      and $corpus->classes->{class};
  $params{search} = ( $self->param('search') && $c_attributes{$self->param('search')} ? $self->param('search') : 'word');
  $params{within} = $self->param('within')
    if ($self->param('within')
	and not $self->param('within') eq '-'
	and not $self->param('within') =~ m/_/
	and $c_structures{$self->param('within')} );
  $params{ignorecase} = $self->param('ignorecase');
  $params{ignorediacritics} = $self->param('ignorediacritics');
  $params{ignoremeta} = $self->param('ignoremeta') || 0;
  $params{struct_constraint_struct}  = $self->param('in-struct')
    if $self->param('in-struct')
	and $self->param('in-struct') =~ m/_/
 	and $c_structures{$self->param('in-struct')};
  $params{struct_constraint_query} = $self->param('struct-query');
  $params{align_query_corpus} = $self->param('in-align')
    if $self->param('in-align') and $c_aligns{$self->param('in-align')};
  $params{align_query_not} = $self->param('not-align');
  $params{align_query} = $self->param('align-query');
  if ($self->param('show')) {
    $params{show} = ref $self->param('show') eq 'ARRAY' ?
      $self->param('show') : [ $self->param('show') ] ;
    $params{show} = [ grep { $c_attributes{$_} } @{$params{show}} ];
    $params{show} = ['word'] unless @{$params{show}};
  } else {
    $params{show} = ['word'];
  }
  #NASTY - used in tabulator and match templates
  # should be using result
  $self->param(show => $params{show});
  if ($self->param('align')) {
    $params{align} = ref $self->param('align') eq 'ARRAY' ?
      $self->param('align') : [ $self->param('align') ] ;
    $params{align} = [ grep { $c_aligns{$_} } @{$params{align}} ];
  }
  $params{context} = $self->param('contextsize') ? $self->param('contextsize') . ' words' : '5 words';
  $params{display} = $self->param('display');
  #NASTY - used in tabulator and match templates
  # should be using result
  unless ($params{display} and $params{display} =~ m/^kwic|paragraphs|sentences|wordlist$/) {
    $params{display} = 'kwic';
    $self->param(display => 'kwic');
  }
  $params{startfrom} = $self->param('startfrom') || 1;
  $params{startfrom} = 1 unless $params{startfrom} =~ m/[0-9]+/
		     and $params{startfrom} >= 1
		     and $params{startfrom} <= $maxsize;
  $params{reduce} = 1
    if $self->param('listing') and $self->param('listing') eq 'sample';
  $params{pagesize} = $self->param('size') || 50;
  $params{pagesize} = 50 unless $params{pagesize} =~ m/[0-9]+/
		     and $params{pagesize} >= 1
		     and $params{pagesize} <= $maxpagesize;
  if ( $self->param('sort_a') and $self->param('sort_a') ne 'none') {
    $params{sort}{a}{target}    = $self->param('sort_a');
    $params{sort}{a}{att}       = $self->param('sort_a_att');
    $params{sort}{a}{order}     = $self->param('sort_a_order');
    $params{sort}{a}{direction} = $self->param('sort_a_direction');
  }
  #app->log->debug("Calling query with " . $self->dumper(\%params));

  my $result = $corpus->query(%params);

  if ( $result and $result->isa('CWB::Model::Result') ) {
    $self->app->log->info(
			  'Query processed in '.
			  sprintf('%0.3f', $result->time) . ' s ' .
			  'with ' . $result->hitno . ' hits.' );
  } else {
    $self->app->log->error("Query failed."); #handle fail
    $self->render( text=>'Query failed.' );
    return;
  }

  if ($self->param('cpos') and $self->param('cpos') =~ m/^\d+$/) {
    $self->render( template=>'cpos',
		   result=>$result,
		   corpus=>$corpus,
		   tc=>$tabulator,
		   tooltip=>$tooltip,
		   ur=>$urlator,
		 ) ;
  } elsif ($self->param('format') 
	   and grep { $_ eq $self->param('format') }
	   qw(xls xls csv json perl)  ) {
    $self->app->log->info('Exporting as ' . $self->param('format')
			  . ' (' . scalar @{$result->hits} . ' hits).');
    given ($self->param('format')) {
      when ('json') { $self->render(json => { %{$result} } ); }
      when ('perl') { $self->render(text => $self->dumper($result), format=>'perl' ); }
      when (/csv|xls/)  {
	if ($table_export) {
	  my $tmpdir = File::Temp->newdir(File::Spec->catdir($config->{tmp}, 'cuwi_tmp_XXXXX'), CLEANUP=>1, );
	  my $tmpfile = File::Spec->catfile($tmpdir->dirname, 'cuwi_search_results.' . $self->param('format'));
	  $self->stash(tmpdir => $tmpdir ); # stash it until tx end for cleanup

	  my $h="Spreadsheet::Write"->new(
				   file    => $tmpfile,
				   format  => $self->param('format'),
				   sheet   => 'Results',
				  );
	  my $tabspreader = sub  {
	    my $attributes = shift;
	    my ($left, $match, $right) = @_;

	    $attributes = $attributes->[0] if ref $attributes->[0];

	    my $i = 0;
	    my @row = ();
	    foreach my $att (@{$attributes}) {
	      push @row, [ $att,
			   (map { substr($_->[$i], 0, 1) eq '=' ? '_' . $_->[$i] : $_->[$i] } @{$left}),
			   (map { substr($_->[$i], 0, 1) eq '=' ? '<< _' . $_->[$i] . ' >>' : '<< ' . $_->[$i]. ' >>' } @{$match}),
			   (map { substr($_->[$i], 0, 1) eq '=' ? '_' . $_->[$i]  : $_->[$i] } @{$right}),
			 ];
	      $i++;
	    }
#	    $self->app->log->info('TAB: ' . $self->dumper(@$attributes), $self->dumper(@row));
	    return @row;
	  };

	  if (not $result->table) {
	    # not wordlist
	    foreach my $hit (@{$result->hits}) {
	      my @rows = $tabspreader->($result->attributes, $hit->{left}, $hit->{match}, $hit->{right});
	      $h->addrow( map { {content => $_, type=>'string' } } join (', ', 'cpos: ' . $hit->{cpos} .
									 (exists $hit->{subcorpus} ? '@' . $hit->{subcorpus} : ''),
									 (map {$_ . ': ' . $hit->{data}{$_} } keys %{$hit->{data}} )),
			  @{shift @rows});
	      if (@rows) {
		foreach my $row (@rows) {
		  $h->addrow( map { {content => $_, type=>'string' } } '', @{$row});
		}
	    }
	      foreach (keys %{$hit->{aligns}}) {
		$h->addrow( map { {content => $_, type=>'string' } } '@' . $_, join(' ', map { $_->[0] } @{${$hit->{aligns}}{$_}}));
	      }
	    }
	  } else {
	    #wordlist
	    foreach my $hit ( @{$result->hits} ) {
	      $h->addrow(
			 { content => join(" ", map { @{$_} } @{$hit->[0]} ), type=>'string' },
			 { content => $hit->[1], type=>'number'}
			);
	    }
	  }
	  $h = undef;

	  $self->res->headers->header('Content-Disposition' => 'attachment; filename="cuwi_search_results.' . $self->param('format'));
	  $self->res->headers->content_type('application/' . $self->param('format'));
	  my $ss = Mojolicious::Static->new(root=>'/');
	  $ss->serve($self, $tmpfile)
	    or $self->app->log->info('Export failed, file not found.');
	  $self->rendered;
	  } else { $self->render(text => 'Perl package Spreadsheet::Write not installed. Sorry.') };
      }
      default { $self->render(text=>'This was impossible, so you are not reading it.');  }
    }
  } else {
    $self->render( template=>'search',
		   result=>$result,
		   corpus=>$corpus,
		   tc=>$tabulator,
		   tooltip=>$tooltip,
		   table_export=>$table_export,
		 );
  }
} ;


any "/login/:corpus" => sub {
  my $self = shift;
  my $authcorpus = $self->param('corpus');
  my $username = $self->param('username');
  my $password = $self->param('password');
  my $domain = $config->{corpora}{AUTH}{$authcorpus}{domain};
  my $auth = $config->{DOMAINS}{$domain};
  my $redirection = $self->session('redirection');
  my $retry = $self->session('retry') || 0;
  my $error = $self->flash('error');

  if ($username and $password and $auth) { #authenticate and redirect back
    $self->app->log->info("Authenticating $username for $domain");
    if ($config->{DOMAINS}{$domain}{$username} eq $password) {
      $self->app->log->info("Authenticated $username for $domain - success.");
      $self->session('username', $username);
      $self->session('retry', 0);
      $self->session('redirection', undef);
      $self->redirect_to(defined $redirection ? $redirection : $config->{root} . "/$authcorpus");
    } else {
      $self->app->log->info("Authentication for $username in $domain failed, retrying.");
      $self->session('retry', ++$retry);
      $self->redirect_to('/' . $config->{root}) and return if $retry > 5;
      $self->render(
		    template=>'login',
		    error => "Authentication error. Try again."
		   );
    }
  } else {
    $self->render(
		  template=>'login',
		  error => $error,
		 );
  }

};



# use this to redirect - (migh be obsoleted by ParamValidate)
$sanitize = sub {
  my $self = shift;

 #ALSO:
 # and $self->param('sort_a') =~ m/^(left|match|right)$/
 # and $self->param('sort_a_order') =~ m/^(ascending|descending)$/
 # and $self->param('sort_a_direction') =~ m/^(natural|reversed)$/

  $self->param('contextsize', 7)
    unless $self->param('contextsize')
      and '' . $self->param('contextsize') =~ m{[0-9]+};
  $self->param('show', 'word')
    unless $self->param('show');
  $self->param('search', 'word')
    unless $self->param('search');
  $self->param('size', 50)
    unless $self->param('size')
      and '' . $self->param('size') =~ m{[0-9]+}
      and $self->param('size') <= $maxsize;
  $self->param('startfrom', 1)
    unless $self->param('startfrom')
      and '' . $self->param('startfrom') =~ m{[0-9]+};
};

$tabulator = sub { #$c is controller, means generate contex links
  my ($tokens, $c) = (@_);
  my $st = '<span class="part">'; my $et = '</span>';
  my @attrs; @attrs = $c->param('show') if $c;

  if ($c) {
    #process lines like: [ [ je, V ] [ bil, K ] ]  [ word, POS ]
    my %query; my $i = 0;
    foreach my $attr (@attrs) {
      my $query = join(' ', map {$_->[$i]} @$tokens ) ;
      foreach my $j (0 .. scalar @$tokens - 1) {
	$tokens->[$j][$i] = $c->link_to_here({query=>$query,
					      search=>$attr,
					      display=>'kwic',
					      ignoremeta=>1},
				    sub { return $tokens->[$j][$i] });
      }
      $i++;
    }
  }
  return join(' ',
	      map {
		'<span class="token">' . 
		  $st . join("$et$st", @$_) . $et 
		    . '</span>';
	      } @$tokens
	     );
};

$urlator = sub {
  my $str = shift;
      return $str unless $str =~ m{^(http|https|ftp|sftp|)://\w+};
  my $c = shift;
  return $c->link_to($str, $str);
};

# $toolitip->($controller, anchor_text=> 'title', 'text');
# $toolitip->($controller, anchor_text=> 'text');
$tooltip = sub {
  my ($c, $anchor, $title, $text);
  $text = pop;
  ($c, $anchor, $title) = @_;
  $title //= $anchor;
  return $anchor unless $text;

  $c->stash('tooltip_id', 0) unless $c->stash('tooltip_id');
  $c->stash('tooltip_id', $c->stash('tooltip_id') +1 );
  my $tid = 'ttip' . $c->stash('tooltip_id');
  $c->stash('tooltipdata', '') unless $c->stash('tooltipdata');
  my $ttext = "\n<div id='$tid'>\n" . $text . "\n</div>\n";
  $c->stash('tooltipdata', $c->stash('tooltipdata') . $ttext);
  return (b("<a class='ttip' href='#$tid' rel='#$tid' title='$title' >$anchor</a>"));
};

app->start;

__DATA__

@@ index.html.ep
% layout 'main', title=>'Form';

% if ($config->{blurb}) {
  <p><%== $config->{blurb} %></p>
% }

% if (stash('cwbexception')) {
<div class="exception">
%= join(' ', @{stash('cwbexception')});
</div>
% }

<div class="corpora">
 <h3>Available corpora:</h3>
 <ul>
% my $corpora = $model->corpora;
% foreach my $corpusname ( sort keys %{$corpora} ) {
%   next if exists $config->{corpora}{OPTIONS}{no_browse}
%	    and grep { $_ eq $corpusname } @{$config->{corpora}{OPTIONS}{no_browse}} ;
   <li><a href="/<%= $config->{root} . '/' . $corpusname %>"><b><%= $corpora->{$corpusname}->NAME %></b>: <%= $corpora->{$corpusname}->title %></a> </li>
% }
 </ul>
</div>

@@ login.html.ep
% layout 'main', title=>'Login';
  <div class="form">
    <%= form_for $self->req->url => ( method => "post") => begin %>
       Username: <%= text_field 'username', size=>10 %>
       Password: <%= password_field 'password', size=>20 %>
      <%= submit_button 'Login' %>
    <% end %>
  </div>

% if (stash('error')) {
  <div class="exception">
%=   stash('error')
  </div>
% }

@@ corpus.html.ep
% layout 'main', title=>'Form';
%= include 'form', query=>undef, contextsize=>7, size=>50, startfrom=>0, listing=>'all', tooltip => $tooltip

% if (stash('cwbexception')) {
<div class="exception">
%= join(' ', @{stash('cwbexception')});
</div>
% }

  <div class="description">
    <%== $corpus->describe('en') %>
% my @atts = grep { $corpus->tooltip(attribute => $_, 'en') }
%    @{$corpus->attributes};
% if (@atts) {
  <h2>Attribute Descriptions</h2>
  <ul>
%   foreach my $att (@atts) {
    <li><b><%= $att %></b>:
     <%= $corpus->tooltip(attribute => $att, 'en') %>
    </li>
%   }
  </ul>
% }
% my @satts = grep { $corpus->tooltip(structure => $_, 'en') }
%    @{$corpus->structures};
% if (@satts) {

  <h2>Structural Attribute Descriptions (Tags)</h2>
  <ul>
%   foreach my $satt (@satts) {
    <li><b><%= $satt %></b>:
     <%= $corpus->tooltip(structure => $satt, 'en') %>
    </li>
%   }
  </ul>
% }
% my @peers = @{$corpus->peers};
% my $corpora = $model->corpora;
% if (@peers) {

  <h2>Peer Corpora</h2>
  <ul>
%   foreach my $p (@peers) {
    <li><a href="/<%= $config->{root} . '/' . $p %>"><b><%= $corpora->{$p}->NAME %></b>: <%= $corpora->{$p}->title %></a></li>
%   }
  </ul>
% }
% if (keys %{$corpus->stats}) {

  <h2>Statistics</h2>
  <table class="stats">
%  if (${$corpus->stats}{tokens}) {
    <tr><td>Size (tokens):</td><td class="num"><%= 1 + ${$corpus->stats}{tokens}  %></td></tr>
%  }
%  if (scalar @{${$corpus->stats}{attributes}}) {
    <tr><th>Positional attributes:</th></tr>
%   foreach my $att (@{${$corpus->stats}{attributes}}) {
    <tr><td><%= $att->[0] %>:</td><td class="num"><%= $att->[1] %></td><td> attributes </td><td class="num"><%= $att->[2] %></td><td> types </td>
% if (exists ${$corpus->stats}{freqs}{$att->[0]}) {
   <td><a href="/<%= $config->{root} . '/' . $corpus->name . '/frequencies/' . $att->[0] %>">frequencies</a></td>
% }
</tr>
%   }
%  }
%  if (scalar @{${$corpus->stats}{structures}}) {
    <tr><th>Structural attributes:</th></tr>
%   foreach my $att (@{${$corpus->stats}{structures}}) {
    <tr><td><%= $att->[0] %>:</td><td class="num"><%= $att->[1] %></td><td> regions </td></tr>
%   }
%  }
%  if (scalar @{${$corpus->stats}{alignements}}) {
    <tr><th>Alignement attributes:</th></tr>
%   foreach my $att (@{${$corpus->stats}{alignements}}) {
    <tr><td><%= $att->[0] %>:</td><td class="num"><%= $att->[1] %></td><td> alignement blocks </td></tr>
%   }
%  }
  </table>
%}

% if ($corpus->can('subcorpora')) {
  <h2>Subcorpora</h2>
  <ul>
 <ul>
% my $corpora = $model->corpora;
% foreach my $corpusname ( sort @{$corpus->subcorpora} ) {
   <li><a href="/<%= $config->{root} . '/' . $corpusname %>"><b><%= $corpora->{$corpusname}->NAME %></b>: <%= $corpora->{$corpusname}->title %></a> </li>
% }
 </ul>
% }
  </div>


@@ form.html.ep
  <div class="form">
    <%= form_for "/$config->{root}/" . $corpus->name . "/search", ( method => "get") => begin %>
    <%= $tooltip->($self, 'Query', "The search query can contain simple words with optional ? and * place-holders. Your query will be converted into a CQP langauge query, using the 'Search' attributes bellow. The search result page will display how the simple search is transformed into a CQP query. If CQP syntax (triggered by any use of quoting in the search query) is detected, no conversion is applied and the 'Search' attributes are ignored for that term. If you want full CQP syntax for the whole query, preceede the query with character ~ followed with a space.") %>:</a>&nbsp;&nbsp;<%= text_field 'query', size=>50 %>
% if (@{$corpus->peers}) {
<%= $tooltip->($self, 'Corpus', 'In a corpus group, you can send the search to a different corpus in the group by selecting the name of the ecorpus here.') %>: <%= select_field 'peer', [$corpus->name, @{$corpus->peers}] %>
% }
% if ($corpus->can('classes') and 0 + keys %{$corpus->classes}) {
    <%= $tooltip->($self, 'Subcorpora', 'In a virtual corpus, you can select a subclass of subcorpora here.') %>: <%= select_field 'class', [$self->param('class') ? $self->param('class') : ${$corpus->classnames}[0] , @{$corpus->classnames}] %>
% }
    <div class="search">
    <span class="label"><%= $tooltip->($self, Search => 'Search attributes', 'Select the attribute the search is to be performed on. If you need different attributes in the same query, you need to use the CQP syntax. When using CQP syntax, the selected Search attribute is ignored. The attributes are extracted from the corpus description in the corpus registry (so possibly some are less useful then others).') %>:</a></span>
% my $checked = 0;
% foreach my $att (@{$corpus->attributes}) {
  % my $ttip = $corpus->tooltip(attribute => $att, 'en');
     <span class="ctrl"><%= radio_button_x 'search' => $att, $checked++ ? () : (checked => 'checked') %>
  % if ($ttip) {
    <%= $tooltip->($self, $att, $ttip) %><% } else {  %>&nbsp;<%= $att %>
  % }
    </span>
% }
    </div>

% my %withins = map { $_ => 1 } 
%    grep { not m{\w+[_]\w+} } @{$corpus->structures};
% if ( keys %withins ) {
% $self->param('within', 's') unless $self->param('within');
    <%= $tooltip->($self, 'Within', 'Constraint to keep the whole match inside a structural field, such as a sentence or paragraph. \'s\' is the default since it is useful for linguistic queries.') %>: <%= select_field 'within', ['-', keys %withins] %>
<span class="form-h-strut"></span>
% }
     Ignore:
      <span class="ctrl"><%= check_box_x ignorecase => 1       %> case</span>
      <span class="ctrl"><%= check_box_x ignorediacritics => 1 %> diacritics</span>

%  my %structs = map { $_ => 1 }
%    grep { m{\w+[_]\w+} } @{$corpus->structures};
% if ( keys %structs ) {
    <div class="structs">
      <%= $tooltip->($self, 'Only where', 'Structural constraint', 'Requires the match to be inside a structural region (xml tag) with the selected attribute matching the constraint. Can be used for selection of a specific text, author or part of speech, depending on corpus markup.') %> <%= select_field 'in-struct', ['-', keys %structs] %>
      <%= $tooltip->($self, 'matches', 'Structural constraint Query', 'Single term query to match structural attribute (XML attribute) value. Rules for treatment of a single CQP regexp (without []) apply.') %>:&nbsp;&nbsp;<%= text_field 'struct-query', size=>24 %>
    </div>
% }
%  my %alignes = map { $_ => 1 } @{$corpus->alignements};
% if ( keys %alignes ) {
    <div class="structs">
    <%= select_field 'not-align', [ [If => 0], [Unless => 1] ] %>
    <%= $tooltip->($self, 'aligned', 'Alignement constraint', 'Requires the aligned region to match (or, alternatively, not match) the constraint. Can be used for excluding unwanted matches based on alignement information. (Regardless if alignement is shown.) Option \'*\' will apply to any existing alignemed corpora.') %> <%= select_field 'in-align', ['-', keys %alignes, '*'] %>
   <%= $tooltip->($self, 'matches', 'Alignement constraint Query', 'Single term query to match algined region. Rules for treatment of a single CQP regexp (without []) apply.') %> :</a>&nbsp;&nbsp;<%= text_field 'align-query', size=>16 %>
    </div>
% }

    <div class="show">
    <span class="label"><%= $tooltip->($self, 'Show', 'Show attributes', 'Select which attributes are to be displayed with your search results. If multiple attributes are selected, they will be aligned horizontally and displayed in different colors. The attributes are extracted from the corpus description in the corpus registry (so possibly some are less useful then others).') %>:</span>
% $checked = 0;
% foreach my $att (@{$corpus->attributes}) {
  % my $ttip = $corpus->tooltip(attribute => $att, 'en');
     <span class="ctrl"><%= check_box_x 'show' => $att, $checked++ ? () : (checked => 'checked') %>
  % if ($ttip) {
    <%= $tooltip->($self, $att, $ttip) %><% } else {  %>&nbsp;<%= $att %>
  % }
   </span>
% }
    </div>
% if (scalar @{$corpus->alignements}) {
% if ($corpus->can('general_align') and $corpus->general_align) {
     <%= $tooltip->($self, 'Align', 'Display any available alignements.') %>:</a>
     <span class="ctrl"><%= check_box_x 'align' => 1 %></span>
% } else {
     Align:
% foreach my $align (@{$corpus->alignements}) {
  % my $ttip; $ttip = ${$model->corpora}{$align}->title if exists ${$model->corpora}{$align};
     <span class="ctrl"><%= check_box_x 'align' => $align %>
  % if ($ttip) {
    <%= $tooltip->($self, $align, $ttip) %><% } else {  %>&nbsp;<%= $align %>
  % }
  </span>
%  }
% }
 <br />
%} #alignements
    <span class="ctrl"><%= $tooltip->($self, 'Context tokens', 'Set the number or left and right tokens to be displayed in KWIC (keyword in contex) display mode. Note that punctuation characters are also tokens.') %>: <%= text_field 'contextsize', size=>2, value=>7 %></span>
    <span class="ctrl"><%= $tooltip->($self, 'Display mode', 'Selects the display mode used to display the results.<br /><b>KWIC</b> (keyword in context) displays the results as a table, with the hit in the middle and the selected number of tokens on both sides.<br /><b>Sentences</b> mode displays the whole sentence, as marked in the corpus, for each hit.<br /><b>Paragraphs</b> does the same for paragraphs. Both modes are only available if structural attributes to support them are present in the corpus.<br /><b>Wordlist</b> tabulates the hits and shows the number of occurencies for each hit - to be used with wildcards (\'?\' and \'*\') i.e. to find different word forms occurances.') %>:
% my @extras = grep { $_ } map { my $s; $s = 'paragraphs' if $_ eq 'p'; $s = 'sentences' if $_ eq 's'; $s; }
%  @{$corpus->structures};
 <%= select_field 'display', ['kwic', @extras, 'wordlist'] %>
 </span>
    <br />
    <span class="ctrl"><%= $tooltip->($self, 'Listing mode', '<b>Sample</b> displays a random sample of hits. Hit reload to see a different sample. <b>All</b> lists all the hits with result pages.</span>') %>: <%= select_field 'listing', [qw/all sample/] %></span>
    <span class="ctrl"><%= $tooltip->($self, 'Results', 'Sets the number or results in the random sample or per page when all the results are being listed.') %>: <%= select_field 'size', [50, 100, 200, 500, 1000, 5000] %></span>
    <br />
    <%= hidden_field startfrom => 1 %>
    <%= $tooltip->($self, 'Sort', 'Sorting', 'Select a sort criterium: you can select position (match, left - preceeding token and right - following token), content (word or any other positional attribute), order (ascending, descending) and direction (natural - from the start or reversed - from the end of the token).') %>:
    <div class="sort">
    <%= select_field 'sort_a',           [qw(none match left right)] %>
    <%= select_field 'sort_a_att',       $corpus->attributes %>
    <%= select_field 'sort_a_order',     [qw(ascending descending)] %>
    <%= select_field 'sort_a_direction', [qw(natural reversed)] %>
    </div>
    <span class="submit"><%= submit_button 'Run Query' %></span>
  <% end %>
  </div>

@@ commented.out.html
%#    <%= select_field 'sort_b',           [qw(none left right match)] %>
%#    <%= select_field 'sort_b_att',       $corpus->attributes %> 
%#    <%= select_field 'sort_b_order',     [qw(ascending descending)] %> 
%#    <%= select_field 'sort_b_direction', [qw(natural reversed)] %><br />
%#    <%= select_field 'sort_c',           [qw(none left right match)] %>
%#    <%= select_field 'sort_c_att',       $corpus->attributes %>
%#    <%= select_field 'sort_c_order',     [qw(ascending descending)] %>
%#    <%= select_field 'sort_c_direction', [qw(natural reversed)] %>


@@ cpos.html.ep
% layout 'main', title=>'in ' . $corpus->name . ' for position ' . $result->cpos ;
% if (stash('cwbexception')) {
<div class="exception">
%= join(' ', @{stash('cwbexception')});
</div>
% }
% if ($result->hits and defined $result->hits->[0]) {
%  my $m = $result->hits->[0];
<div class="structure_report">
  <table>
  <tr><th>cpos:</th><td><%= $result->cpos %></td></tr>
%  foreach my $struct (keys %{$m->{data}}) {
      <tr><th><%= $struct . ':' %></th><td><%= $ur->($m->{data}{$struct}, $self) %></td></tr>
%   }
 </table>
</div>
<div class="report">
  <p>Detailed view for corpus position <b><%= $result->cpos %></b> from a query for <span class="querytext"><%= link_to_here {query => $result->query, cpos => undef, ignoremeta => 0} => begin %><%= $result->query %><% end %></span>, retrieved in <%= sprintf('%0.3f', $result->time) %> s.
  </p>
</div>
<div class="matches">
%   if (exists $config->{corpora}{$corpus->name}{preview}) {
%    if (exists $m->{data}{$config->{corpora}{$corpus->name}{preview}}) {
   <a href="<%= $m->{data}{$config->{corpora}{$corpus->name}{preview}} %>"><img class="preview" src="<%= $m->{data}{$config->{corpora}{$corpus->name}{preview}} %>" /></a>
%    }
%   }
 <p>
  <span class="attlabel"><%== $tc->([$self->param('show')]); %></span>
  <%== $tc->($m->{left}); %>
  <span class="match"><%== $tc->($m->{match}); %></span>
  <%== $tc->($m->{right}); %>
 </p>
% foreach my $align (keys %{$m->{aligns}}) {
  <p class="align"><span class="parno"><a href="#" class="tooltip">&nbsp;@&nbsp;<span class="custom help"><em>Alignemt to <%= $align %></em><%= exists ${$model->corpora}{$align} ? ${$model->corpora}{$align}->title : '' %></span></a></span><span class="align"><%== $tc->($m->{aligns}{$align}); %></span></p>
% }
</div>
%  }

@@ search.html.ep
% layout 'main', title=>'in ' . $corpus->name . ' for ' . $result->query ;
<%= include 'form' %>
  <div class="report">
% if ($self->param('display') eq 'wordlist') {
   <p>Retrieved <b><%=  scalar @{$result->hits} %></b> 
% if ($result->reduce) {
  out of <b><%= $result->distinct %></b>
% }
 distinct matches from <b><%= $result->hitno %></b> hits for <span class="querytext"><%= link_to_here {query => $result->query, ignoremeta => 0} => begin %><%= $result->query %><% end %></span>
% } elsif ($result->reduce) {
   <p>Sample of <b><%=  scalar @{$result->hits}  %></b> matches out of <b><%= $result->hitno %></b> retrieved for <span class="querytext"><%= link_to_here {query => '+ ' . $result->query, ignoremeta => 0} => begin %><%= $result->query %><% end %></span>
% }
% elsif ($result->pages->{single} or $result->hitno > ${$result->pages}{pagesize}) {
   <p>Matches <b><%= ${$result->pages}{this} %></b> to <b><%= ${$result->pages}{this} +  @{$result->hits} - 1 %></b> out of <b><%= $result->hitno %></b> retrieved for <span class="querytext"><%= link_to_here {query => '+ ' . $result->query, ignoremeta => 0} => begin %><%= $result->query %><% end %></span>
% } else {
   <p><b><%= $result->hitno %></b> matches for <span class="querytext"><%= link_to_here {query => $result->query, ignoremeta => 0} => begin %><%= '+ ' . $result->query %><% end %></span>
% }
 in <%= sprintf('%0.3f', $result->time) %> s.</p>
  </div>
% if (stash('cwbexception')) {
<div class="exception">
%= join(' ', @{stash('cwbexception')});
</div>
% }

% if ($result->hitno) {
<div class="exports">
 Export results:
 <%= link_to_here { format=>'json', start_from=>1, size=>50000 } => begin %><span> JSON </span><% end %>
 <%= link_to_here { format=>'perl', start_from=>1, size=>50000 } => begin %><span> Perl </span><% end %>
% if ($table_export) {
 <%= link_to_here { format=>'csv', start_from=>1, size=>50000 } => begin %><span> CSV </span><% end %>
 <%= link_to_here { format=>'xls', start_from=>1, size=>50000 } => begin %><span> Excel </span><% end %>
% }
</div>
% }

<%= include 'nav' %>

% if ($result->hitno) {
  <div class="matches">
% if ($self->param('display') eq 'kwic') {
  <table>
%  my $nr = ${$result->{pages}}{this};
%  my $subcorpus; 
%  my @single = ( contextsize=>50 );
%  @single = ( display => $result->bigcontext ) if $result->bigcontext;
%  foreach my $m (@{$result->hits}) {
%  if ($m->{subcorpus_name} and $m->{subcorpus_name} ne $subcorpus) {
%    $subcorpus = $m->{subcorpus_name};
    <tr><td colspan="4" class="subcorpus"><%= $subcorpus %></td></tr>
%  }
    <tr>
     <td class="head"><span class="no">
<%= link_to_here $m->{subcorpus_name} ? '../' . $m->{subcorpus_name} . '/search' : '', {cpos=>$m->{'cpos'}, ignoremeta => 0}, (class=>"infobox") => begin %>[<%= $nr++ %>]<span class="custom help"><em>Structural Info</em>
      <b>cpos:</b> <%= $m->{'cpos'} %>
%   foreach my $struct (keys %{$m->{data}}) {
      <br /><b><%= $struct . ':' %></b>  <%= $m->{data}{$struct} %>
%   }
     <br /><i class="info">Click for detailed view.</i>
     </span><% end %></span></td>
     <td class="left"><%== $tc->($m->{left}); %></td>
     <td class="match"><span class="match"><%== $tc->($m->{match}); %></span></td>
     <td class="right"><%== $tc->($m->{right}); %></td>
    </tr>
%   foreach my $align (keys %{$m->{aligns}}) {
    <tr><td class="head"><span class="no"><a href="#" class="tooltip">&nbsp;@&nbsp;<span class="custom help"><em>Alignement to <%= $align %></em><%= exists ${$model->corpora}{$align} ? ${$model->corpora}{$align}->title : '' %></span></td><td colspan="3" class="align"><%== $tc->($m->{aligns}{$align}); %></td></tr>
%   }
%  }
  </table>
% } elsif ($self->param('display') eq 'sentences' or $self->param('display') eq 'paragraphs') {
%  my $nr = ${$result->{pages}}{this};
%  my @single = ( contextsize=>25 );
%  @single = ( display => $result->bigcontext ) if $result->bigcontext;
%  foreach my $m (@{$result->hits}) {
    <p>
     <span class="parno"><%= link_to_here {cpos=>$m->{'cpos'}, ignoremeta => 0}, (class=>"infobox") => begin %>[<%= $nr++ %>]<span class="custom help"><em>Structural Info</em>
      <b>cpos:</b> <%= $m->{'cpos'} %>
%   foreach my $struct (keys %{$m->{data}}) {
      <br /><b><%= $struct . ':' %></b>  <%= $m->{data}{$struct} %>
%   }
     <br /><i class="info">Click for detailed view.</i>
      </span><% end %>
     </span>
     <%== $tc->($m->{left}); %>
     <span class="match"><%== $tc->($m->{match}); %></span>
     <%== $tc->($m->{right}); %>
    </p>
%   foreach my $align (keys %{$m->{aligns}}) {
    <p class="align"><span class="parno"><a href="#" class="tooltip">&nbsp;@&nbsp;<span class="custom help"><em>Alignemt to <%= $align %></em><%= exists ${$model->corpora}{$align} ? ${$model->corpora}{$align}->title : '' %></span></a></span><span class="align"><%== $tc->($m->{aligns}{$align}); %></span></p>
%   }
%  }
% } elsif ($self->param('display') eq 'wordlist') {
  <table>
    <tr class="total"><td> </td><td>TOTAL: <%= $result->distinct %></td><td class="count"><%= $result->hitno %></td></tr>
%  my $nr = 1;
  %  foreach my $m (@{$result->hits}) {
    <tr><td class="head"><span class="no">[<%= $nr++ %>]</td><td><%== $tc->($m->[0], $self) %></td><td class="count"><%= $m->[1] %></td></tr>
  %  }
  </table>
% } else {
  Unknown display mode: query aborted. (Stop playing with my query parameters or I won't be RESTful much longer!)
% }
 </div>
<%= include 'nav' %>

%}

@@ nav.html.ep
% if ($result->hitno and not ${$result->pages}{single}) {
  <div class="nav">
    <%= link_to_here { startfrom => ${$result->pages}{prev}, ignoremeta => 0 } => (class=>'prev') => begin %>Prev<% end %>
    <%= link_to_here { startfrom => ${$result->pages}{next}, ignoremeta => 0 } => (class=>'next') => begin %>Next<% end %>
   <span class="pagelist">
     % foreach my $page (@{$result->pagelist(11)}) {
     %  if ($page eq '...') {
          . . .
     %    next;
     %  }
       <%= link_to_here { startfrom => $page, ignoremeta => 0 } 
            => (class=> ( ${$result->pages}{this} == $page ? 'here' : 'pg') )
            => begin %><%= $page %><% end %>
     % }
   </span>
  </div>
% }

@@ layouts/main.html.ep
<!DOCTYPE HTML>
<html>
 <head>
  <title>CUWI Search <%= $title ? " $title" : '' =%></title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <link rel="stylesheet" href="<%= '/' . $config->{root} . '/style.css' %>"  type="text/css" />
  <link rel="stylesheet" href="<%= '/' . $config->{root} . '/lib/jquery.cluetip.css' %>" type="text/css" />
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="<%= '/' . $config->{root} . '/lib/jquery-1.7.1.min.js' %>"%3E%3C/script%3E'));</script>
 </head>
 <body>
 % if ($self->session('username')) {
 <div class="user">
   Logged in as: <b><%= $self->session('username') %></b>. <%= link_to Logout => '/' . $config->{root} . '/logout' %>
 </div>
 %}
  <h2><%= link_to 'index' => begin %>
    CUWI Search
  <% end %>
 % if (param('corpus')) {
   on
   <%= link_to '/' . $config->{root} . '/' . param('corpus') => begin %>
     <%= ${$model->{corpora}}{param('corpus')}->title %>
   <% end %>
 %}
  </h2>
<%== content %>
% if (stash('tooltipdata')) {
  <%= Mojo::ByteStream->new(stash('tooltipdata')) =%>
% }
   <script src="<%= '/' . $config->{root} . '/lib/jquery.hoverIntent.js' %>"></script>
  <script src="<%= '/' . $config->{root} . '/lib/jquery.bgiframe.min.js' %>"></script>
  <script src="<%= '/' . $config->{root} . '/lib/jquery.cluetip.js' %>"></script>
  <script src="<%= '/' . $config->{root} . '/lib/cuwi.js' %>"></script>
</body>
</html>


@@ cuwi.css
body { font-family: Palatino, Times, serif;
       font-size: 120%;
       background-color: #F0F0F0;
       padding-bottom: 8ex;
}
div.user { font-family: sans-serif; font-size: 50%;   text-align: right; }
div.search, div.show { margin-left: 3.5em; }
div.search > span.label, div.show > span.label { margin-left: -3.5em;  }
div.search > span.label, div.show > span.label { width: 14em; }
span.ctrl { white-space: nowrap; display: inline; }
span.form-h-strut { margin-left: 2em; }
div.show { margin-top: 1ex; }
div.sort { display: inline-block; vertical-align: text-top; }
div.case { float: right; padding-left: 1em; }
span.querytext { font-family: monospace; font-size: 110%; font-weight: bold; }
div.exception { margin: 3em; color: Red; }

div.exports {
  font-size: 80%;
  margin-bottom: 2ex;
}
div.exports > a {
  font-size: 80%;
  font-family: sans-serif;
  text-decoration: none;
  color: white;
  background: orange;
  padding: .35em;
  margin: .4em;
  border-radius: .4em;
}

div.nav   { font-weight: bold; font-size: 80%; }
div.nav > a.prev   { float: left; }
div.nav > a.next   { float: right; }
div.nav > a { padding: .5em; padding-left: 1.5em; padding-right: 1.5em;
              background-color: #3E3E3E; color: white;
}
span.pagelist {
  padding: .5em;
  text-align: center;
  vertical-align: middle;
  background-color: #DEDEDE;
  display: block;
}
span.pagelist > a {
  margin-left:  .3em;
  margin-right: .3em;
}
span.pagelist > a.here {
 color: red;
}
div.report p  { text-align: center; }
div.structure_report  {
  background-color: white;
  padding: 0px;
  width: 80%;
  margin-left: auto; margin-right: auto;
  padding: .4em; padding-bottom: .6em; padding-left: .6em;
  border-left: solid 3px black;
  border-top: solid 3px black;
  border-bottom: solid 3px gray;
  border-right: solid 3px gray;
  border-radius: 5px 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px;
}
div.structure_report table  { padding: .5em; background-color: white; width: 100%; margin-left: auto; margin-right: auto; }
div.structure_report table th { text-align: left; padding-right: 1em; }
span.attlabel { font-variant:small-caps; font-size: 80%; line-height: 170%; padding-right: 2em; }
img.preview { display: block; float: left; padding-top: 0pt; padding: 2em; width: 50%; }
div.matches   { clear: both; }
div.matches { background-color: white;
	      width: 98%;
              padding: 0px;
	      margin-left: auto; margin-right: auto;
}
div.matches p { margin: .25em; margin-left: .5em; margin-right: .5em; }
div.matches table { padding: .5em; background-color: white; margin-left: auto; margin-right: auto; clear: right;}
td.subcorpus { font-weight: bold; }
span.hit  { color: red; font-weight: bold; }
span.match  { color: red; font-weight: bold; }
span.no, span.parno   { font-weight: bold; }
span.parno   { font-weight: bold; vertical-align: top;}
div.matches td  { white-space: nowrap;}
div.matches td.head  { white-space: nowrap; text-align: right;
           padding-left: .3em; padding-right: .3em; }
div.matches td.head a * { text-align: left; white-space: normal; }
div.matches td.left  { text-align: right; vertical-align: text-bottom;}
div.matches td.right { text-align: left;  vertical-align: text-top;}
div.matches td.match { text-align: center; padding-left: .5em; padding-right: .5em;
           color: red; font-weight: bold; vertical-align: middle;}
div.matches td.align { white-space: normal; }
div.matches td.count  { text-align: right; padding-left: 1em;}
div.matches tr.total  { font-weight: bold;}
div.matches tr:nth-child(2n+1) { background-color: #F2F2F2; }
span.token { display: inline-block }
span.part { display: block; text-align: left; }
span.token span.part:nth-child(4n+1) { color: black; }
span.token span.part:nth-child(4n+2) { color: navy; }
span.token span.part:nth-child(4n+3) { color: green; }
span.token span.part:nth-child(4n+4) { color: purple; }
span.token span.part:nth-child(4n+1) > a { color: black; }
span.token span.part:nth-child(4n+2) > a { color: navy; }
span.token span.part:nth-child(4n+3) > a { color: green; }
span.token span.part:nth-child(4n+4) > a { color: purple; }
span.match span.token span.part:first-child { color: red; }
span.hlp span.hlptxt { display: none; }
span.hlp:hover span.helptxt { display: block; }
h2 { margin-left: 2em; margin-right: 2em; text-align: center ; }
h2 + p, div.report, div.corpora { margin-left: 4em; margin-right: 4em; }
div.form { margin-left: auto; margin-right: auto; width: 36em;
	   background-color: white;
	   padding: .4em; padding-bottom: .6em; padding-left: .6em;
	   border-left: solid 3px black;
	   border-top: solid 3px black;
	   border-bottom: solid 3px gray;
	   border-right: solid 3px gray;
}
span.submit { float: right; }
div.corpora > li {
  margin-bottom: .2ex;
  margin-top: .2ex;
}
div.description {
  margin: 3ex;
  font-size: 0.8em;
}
div.description h2 {
  text-align: left;
  margin-left: 0px;
}
div.description > table.stats {
  margin-left: 1.5em;
}
div.description > table.stats > tr > th {
  padding-top: .7em;
  padding-left: 0em;
}
div.description table.stats tr td.num {
  text-align: right;
}
div.description table.stats tr td {
  padding-right: 1em;
}

/* # tooltips from Alexander Dawson,
   # http://sixrevisions.com/css/css-only-tooltips/ */
a.tooltip, a.infobox {
    border-bottom: 1px dotted #000000; color: #000000; outline: none;
    cursor: help; text-decoration: none;
    position: relative;
    white-space: normal;
}
a.ttip, a.infobox {
    border-bottom: 1px dotted #000000; color: #000000; outline: none;
    cursor: help; text-decoration: none;
    white-space: normal;
}
a.tooltip span, a.infobox span {
    display: none;
    position: absolute;
}
a.tooltip:hover span, a.infobox:hover span {
    display: block;
    font-weight: normal;
    border-radius: 5px 5px; -moz-border-radius: 5px; -webkit-border-radius: 5px;
    box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1); -webkit-box-shadow: 5px 5px rgba(0, 0, 0, 0.1); -moz-box-shadow: 5px 5px rgba(0, 0, 0, 0.1);
    font-family: Calibri, Tahoma, Geneva, sans-serif; font-size: 0.7em;
    position: absolute; left: 1em; top: 2em; z-index: 99;
    margin-left: 0; width: 24em;
}
a.infobox:hover span {
    width: 36em;
}
a.infobox:hover i.info {
    display: inline-block;
    margin-top: 1ex;
    border: none;
}
a.tooltip:hover img, a.infobox:hover img {
    border: 0; margin: -10px 0 0 -55px;
    float: left; position: absolute;
}
a.tooltip:hover em, a.infobox:hover em {
    font-family: Candara, Tahoma, Geneva, sans-serif; font-size: 1.2em; font-weight: bold;
    display: block; padding: 0.2em 0 0.6em 0;
}
.classic  { padding: 0.8em 1em; }
.custom   { padding: 0.5em 0.8em 0.8em 2em; }
* html a:hover { background: transparent; }
.classic  {background: #FFFFAA; border: 1px solid #FFAD33;  }
.critical { background: #FFCCAA; border: 1px solid #FF3334; }
.help     { background: #9FDAEE; border: 1px solid #2BB0D7; }
.info     { background: #9FDAEE; border: 1px solid #2BB0D7; }
.warning  { background: #FFFFAA; border: 1px solid #FFAD33; }
